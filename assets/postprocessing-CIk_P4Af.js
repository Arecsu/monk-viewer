var We=Object.defineProperty;var je=(i,t,e)=>t in i?We(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e;var a=(i,t,e)=>je(i,typeof t!="symbol"?t+"":t,e);import{m as Xe,n as I,o as q,S as Ue,p as pe,H as he,R as ee,L as j,q as Ee,g as Y,M as oe,l as Z,r as H,W as ye,s as qe,t as Ye,u as Ze,v as Qe,f as Je,w as E,x as O,y as _,E as x,z as Ke,A as et,O as tt,G as st,c as le,J as rt,K as it,P as nt,T as at,Q as ot,X as ut,Y as ft,Z as lt,N as ct,_ as ht,V as dt,$ as pt,a0 as gt,a1 as Fe,a2 as mt,F as vt,a3 as Et,a4 as _t,a5 as Bt,b as Ct}from"./vendor-three-B7e9swDm.js";/**
 * postprocessing v7.0.0-beta.6 build Mon Feb 10 2025
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015 Raoul van RÃ¼schen
 * @license Zlib
 */var Rt=Object.defineProperty,St=(i,t)=>{for(var e in t)Rt(i,e,{get:t[e],enumerable:!0})},ce=class{constructor(i=0){a(this,"nextId");this.nextId=i}getNextId(){return this.nextId++}reset(i=0){return this.nextId=i,this}},U,W=(U=class extends x{constructor(e){super();a(this,"id");a(this,"_value");a(this,"_overrideValue");this.id=U.idManager.getNextId(),this._value=e,this._overrideValue=null}get value(){return this._overrideValue??this._value}set value(e){this._value=e,this.setChanged()}get overrideValue(){return this._overrideValue}set overrideValue(e){this._overrideValue=e,this.setChanged()}setChanged(){this.dispatchEvent({type:U.EVENT_CHANGE})}},a(U,"EVENT_CHANGE","change"),a(U,"idManager",new ce),U),M,ge=(M=class extends W{constructor(t){super(t),M.increaseReferenceCount(t)}get value(){return super.value}set value(t){const e=super.value;super.value=t,t!==e&&(M.decreaseReferenceCount(e),M.increaseReferenceCount(t),e!==null&&!M.references.has(e)&&e.dispose())}dispose(){var t;(t=this.value)==null||t.dispose()}static decreaseReferenceCount(t){if(t===null)return;const e=M.references,s=e.get(t)??0;s>0&&(s===1?e.delete(t):e.set(t,s-1))}static increaseReferenceCount(t){if(t===null)return;const e=M.references,s=e.get(t)??0;e.set(t,s+1)}},a(M,"references",new Map),M),De=(i=>(i.COLOR="color",i.DEPTH="depth",i.NORMAL="normal",i.POSITION="position",i.ORM="orm",i.EMISSION="emission",i.LUMINANCE="luminance",i))(De||{}),C,d=(C=class extends x{constructor(e){super();a(this,"data");this.data=new Map(e)}get size(){return this.data.size}get[Symbol.toStringTag](){return this.data[Symbol.toStringTag]}clear(){const e=this.data.clear();return this.dispatchEvent({type:C.EVENT_CHANGE}),e}delete(e){return this.data.has(e)?(this.dispatchEvent({type:C.EVENT_DELETE,key:e,value:this.data.get(e)}),this.data.delete(e),this.dispatchEvent({type:C.EVENT_CHANGE}),!0):!1}get(e){return this.data.get(e)}has(e){return this.data.has(e)}set(e,s){return this.data.has(e)&&this.dispatchEvent({type:C.EVENT_DELETE,key:e,value:this.data.get(e)}),this.data.set(e,s),this.dispatchEvent({type:C.EVENT_ADD,key:e,value:s}),this.dispatchEvent({type:C.EVENT_CHANGE}),this}entries(){return this.data.entries()}keys(){return this.data.keys()}values(){return this.data.values()}forEach(e,s){return this.data.forEach(e,s)}[Symbol.iterator](){return this.data[Symbol.iterator]()}},a(C,"EVENT_CHANGE","change"),a(C,"EVENT_ADD","add"),a(C,"EVENT_DELETE","delete"),C),V,Q=(V=class extends x{constructor(){super();a(this,"textureConfigs");a(this,"gBufferStructFields");a(this,"gBufferStructDeclaration");a(this,"gDataStructDeclaration");a(this,"gDataStructInitialization");a(this,"gDataDependencies");const e=new d,s=new d([["Color","color"],["Depth","depth"],["Normal","normal"],["ORM","orm"],["Emission","emission"]]),r=new d([["color","FRAME_BUFFER_PRECISION sampler2D color;"],["depth","DEPTH_BUFFER_PRECISION sampler2D depth;"],["normal","mediump sampler2D normal;"],["orm","lowp sampler2D orm;"],["emission","FRAME_BUFFER_PRECISION sampler2D emission;"]]),n=new d([["color","vec4 color;"],["depth","float depth;"],["normal","vec3 normal;"],["position","vec3 position;"],["orm","vec3 orm;"],["emission","vec3 emission;"],["luminance","float luminance;"]]),o=new d([["color","gData.color = texture(gBuffer.color, UV);"],["depth","gData.depth = texture(gBuffer.depth, UV).r;"],["normal","gData.normal = texture(gBuffer.normal, UV).xyz;"],["position","gData.position = getViewPosition(UV, gData.depth);"],["orm","gData.orm = texture(gBuffer.orm, UV).xyz;"],["emission","gData.emission = texture(gBuffer.emission, UV).rgb;"],["luminance","gData.luminance = luminance(gData.color.rgb);"]]),u=new d([["position",new Set(["depth"])],["luminance",new Set(["color"])]]),f=()=>this.dispatchEvent({type:V.EVENT_CHANGE});e.addEventListener(d.EVENT_CHANGE,f),s.addEventListener(d.EVENT_CHANGE,f),r.addEventListener(d.EVENT_CHANGE,f),n.addEventListener(d.EVENT_CHANGE,f),o.addEventListener(d.EVENT_CHANGE,f),u.addEventListener(d.EVENT_CHANGE,f),this.textureConfigs=e,this.gBufferStructFields=s,this.gBufferStructDeclaration=r,this.gDataStructDeclaration=n,this.gDataStructInitialization=o,this.gDataDependencies=u}},a(V,"EVENT_CHANGE","change"),V),D,ue=(D=class extends x{constructor(e){super();a(this,"data");this.data=new Set(e)}get size(){return this.data.size}get[Symbol.toStringTag](){return this.data[Symbol.toStringTag]}clear(){const e=this.data.clear();return this.dispatchEvent({type:D.EVENT_CHANGE}),e}delete(e){const s=this.data.delete(e);return this.dispatchEvent({type:D.EVENT_CHANGE}),s}has(e){return this.data.has(e)}add(e){return this.data.add(e),this.dispatchEvent({type:D.EVENT_CHANGE}),this}entries(){return this.data.entries()}keys(){return this.data.keys()}values(){return this.data.values()}forEach(e,s){return this.data.forEach(e,s)}[Symbol.iterator](){return this.data[Symbol.iterator]()}},a(D,"EVENT_CHANGE","change"),D),te=class extends ge{constructor(t=null){super(t);a(this,"uniformListeners");this.uniformListeners=new WeakMap}bindUniform(t){if(!this.uniformListeners.has(t)){const e=()=>{t.value=this.value};this.uniformListeners.set(t,e),this.addEventListener(W.EVENT_CHANGE,e)}t.value=this.value}unbindUniform(t){this.uniformListeners.has(t)&&this.removeEventListener(W.EVENT_CHANGE,this.uniformListeners.get(t))}},b,se=(b=class extends x{constructor(){super();a(this,"defines");a(this,"uniforms");a(this,"gBuffer");a(this,"textures");a(this,"_gBufferConfig");a(this,"listener");const e=new ue(["Color"]),s=new d,r=new d,n=new d,o=()=>this.setChanged();e.addEventListener(ue.EVENT_CHANGE,o),s.addEventListener(d.EVENT_CHANGE,o),r.addEventListener(d.EVENT_CHANGE,o),n.addEventListener(d.EVENT_CHANGE,o),n.addEventListener(d.EVENT_ADD,u=>u.value.addEventListener(W.EVENT_CHANGE,o)),n.addEventListener(d.EVENT_DELETE,u=>u.value.removeEventListener(W.EVENT_CHANGE,o)),this.listener=o,this.defines=s,this.uniforms=r,this.textures=n,this.gBuffer=e,this._gBufferConfig=null}get gBufferConfig(){return this._gBufferConfig}set gBufferConfig(e){this._gBufferConfig!==null&&this._gBufferConfig.removeEventListener(Q.EVENT_CHANGE,this.listener),e!==null&&e.addEventListener(Q.EVENT_CHANGE,this.listener),this._gBufferConfig=e,this.setChanged()}get buffers(){return this.textures}get hasDefaultBuffer(){return this.textures.has(b.BUFFER_DEFAULT)}get defaultBuffer(){return this.textures.get(b.BUFFER_DEFAULT)??null}set defaultBuffer(e){this.setBuffer(b.BUFFER_DEFAULT,e)}get frameBufferPrecisionHigh(){var e,s;return((s=(e=this.defaultBuffer)==null?void 0:e.value)==null?void 0:s.type)!==Y}setChanged(){this.dispatchEvent({type:b.EVENT_CHANGE})}setBuffer(e,s){if(s instanceof te)this.textures.set(e,s);else{const r=this.textures.get(e);r!=null?r.value=s:this.textures.set(e,new te(s))}}getBuffer(e){var s;return((s=this.textures.get(e))==null?void 0:s.value)??null}removeDefaultBuffer(){return this.textures.delete(b.BUFFER_DEFAULT)}dispose(){var e;for(const s of this.textures.values())(e=s.value)==null||e.dispose()}},a(b,"EVENT_CHANGE","change"),a(b,"BUFFER_DEFAULT","BUFFER_DEFAULT"),b),J=class extends ge{constructor(t=null){var e;super(t);a(this,"texture");this.texture=new te((e=this.value)==null?void 0:e.texture)}get value(){return super.value}set value(t){super.value=t,this.texture.value=t!==null?t.texture:null}},A,fe=(A=class extends x{constructor(){super();a(this,"defines");a(this,"uniforms");a(this,"renderTargets");const e=new d,s=new d,r=new d,n=()=>this.setChanged();e.addEventListener(d.EVENT_CHANGE,n),s.addEventListener(d.EVENT_CHANGE,n),r.addEventListener(d.EVENT_CHANGE,n),r.addEventListener(d.EVENT_ADD,o=>o.value.addEventListener(W.EVENT_CHANGE,n)),r.addEventListener(d.EVENT_DELETE,o=>o.value.removeEventListener(W.EVENT_CHANGE,n)),this.defines=e,this.uniforms=s,this.renderTargets=r}get buffers(){return this.renderTargets}get hasDefaultBuffer(){return this.renderTargets.has(A.BUFFER_DEFAULT)}get defaultBuffer(){return this.renderTargets.get(A.BUFFER_DEFAULT)??null}set defaultBuffer(e){this.setBuffer(A.BUFFER_DEFAULT,e)}get frameBufferPrecisionHigh(){var s;const e=(s=this.defaultBuffer)==null?void 0:s.value;return e==null?!1:e.texture.type!==Y}setChanged(){this.dispatchEvent({type:A.EVENT_CHANGE})}setBuffer(e,s){if(s instanceof J)this.renderTargets.set(e,s);else{const r=this.renderTargets.get(e);r!=null?r.value=s:this.renderTargets.set(e,new J(s))}}getBuffer(e){var s;return((s=this.renderTargets.get(e))==null?void 0:s.value)??null}removeDefaultBuffer(){return this.renderTargets.delete(A.BUFFER_DEFAULT)}dispose(){var e,s,r;for(const n of this.renderTargets.values())(s=(e=n.value)==null?void 0:e.depthTexture)==null||s.dispose(),(r=n.value)==null||r.dispose()}},a(A,"EVENT_CHANGE","change"),a(A,"BUFFER_DEFAULT","BUFFER_DEFAULT"),A),F=class extends le{constructor(i){super(Object.assign({name:"FullscreenMaterial",glslVersion:ht,blending:ct,depthWrite:!1,depthTest:!1},i)),Object.assign(this.uniforms,{projectionMatrix:new E(null),projectionMatrixInverse:new E(null),viewMatrixInverse:new E(null),cameraParams:new E(new dt),resolution:new E(new q),inputBuffer:new E(null)}),this.outputPrecision="lowp",this.onBeforeCompile=(t,e)=>{e.getRenderTarget()===null&&this.outputPrecision!=="lowp"&&(this.outputPrecision="lowp",this.needsUpdate=!1)}}get outputPrecision(){return this.defines.OUTPUT_COLOR_PRECISION}set outputPrecision(i){this.defines.OUTPUT_COLOR_PRECISION!==i&&(this.defines.OUTPUT_COLOR_PRECISION=i,this.needsUpdate=!0)}get frameBufferPrecisionHigh(){return this.defines.FRAME_BUFFER_PRECISION_HIGH!==void 0}set frameBufferPrecisionHigh(i){this.frameBufferPrecisionHigh!==i&&(i?this.defines.FRAME_BUFFER_PRECISION_HIGH=!0:delete this.defines.FRAME_BUFFER_PRECISION_HIGH,this.needsUpdate=!0)}get inputBuffer(){return this.uniforms.inputBuffer.value}set inputBuffer(i){this.frameBufferPrecisionHigh=i!==null&&i.type!==Y,this.uniforms.inputBuffer.value=i}get near(){return this.uniforms.cameraParams.value.x}get far(){return this.uniforms.cameraParams.value.y}copyCameraSettings(i){this.uniforms.projectionMatrix.value=i.projectionMatrix,this.uniforms.projectionMatrixInverse.value=i.projectionMatrixInverse,this.uniforms.viewMatrixInverse.value=i.matrixWorld;const t=this.uniforms.cameraParams.value;t.set(i.near,i.far,t.z);const e=this.defines.PERSPECTIVE_CAMERA!==void 0;i instanceof pt&&!e?(this.defines.PERSPECTIVE_CAMERA=!0,this.needsUpdate=!0):e&&(delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}setSize(i,t){this.uniforms.resolution.value.set(i,t,1/i,1/t);const s=this.uniforms.cameraParams.value;s.z=i/t}},S=-1,y,re=(y=class extends x{constructor(e=S,s=S,r=1){super();a(this,"baseSize");a(this,"preferredSize");a(this,"effectiveSize");a(this,"_pixelRatio");a(this,"_scale");this.baseSize=new I(1,1),this.preferredSize=new I(e,s),this.effectiveSize=new I,this._pixelRatio=1,this._scale=r,this.addEventListener(y.EVENT_CHANGE,()=>this.updateEffectiveSize()),this.updateEffectiveSize()}updateEffectiveSize(){const e=this.baseSize,s=this.preferredSize,r=this.effectiveSize;r.copy(e),s.width!==S?r.width=s.width:s.height!==S&&(r.width=Math.round(s.height*(e.width/Math.max(e.height,1)))),s.height!==S?r.height=s.height:s.width!==S&&(r.height=Math.round(s.width/Math.max(e.width/Math.max(e.height,1),1))),r.multiplyScalar(this.scaledPixelRatio).floor()}get width(){return this.effectiveSize.width}get height(){return this.effectiveSize.height}get aspectRatio(){return this.baseSize.width/this.baseSize.height}get pixelRatio(){return this._pixelRatio}set pixelRatio(e){this._pixelRatio!==e&&(this._pixelRatio=e,this.setChanged())}get scale(){return this._scale}set scale(e){this._scale!==e&&(this._scale=e,this.preferredSize.setScalar(S),this.setChanged())}get scaledPixelRatio(){return this._pixelRatio*this._scale}get baseWidth(){return this.baseSize.width}set baseWidth(e){this.baseSize.width!==e&&(this.baseSize.width=e,this.setChanged())}get baseHeight(){return this.baseSize.height}set baseHeight(e){this.baseSize.height!==e&&(this.baseSize.height=e,this.setChanged())}setBaseSize(e,s){(this.baseSize.width!==e||this.baseSize.height!==s)&&(this.baseSize.set(e,s),this.setChanged())}setSize(e,s){this.setBaseSize(e,s)}copyBaseSize(e){this.baseSize.equals(e.baseSize)||(this.baseSize.copy(e.baseSize),this.setChanged())}get preferredWidth(){return this.preferredSize.width}set preferredWidth(e){this.preferredSize.width!==e&&(this.preferredSize.width=e,this.setChanged())}get preferredHeight(){return this.preferredSize.height}set preferredHeight(e){this.preferredSize.height!==e&&(this.preferredSize.height=e,this.setChanged())}setPreferredSize(e,s){(this.preferredSize.width!==e||this.preferredSize.height!==s)&&(this.preferredSize.set(e,s),this.setChanged())}copyPreferredSize(e){this.preferredSize.equals(e.preferredSize)||(this.preferredSize.copy(e.preferredSize),this.setChanged())}resetPreferredSize(){(this.preferredSize.width!==S||this.preferredSize.height!==S)&&(this.preferredSize.set(S,S),this.setChanged())}copy(e){this.equals(e)||(this.preferredSize.copy(e.preferredSize),this.baseSize.copy(e.baseSize),this._pixelRatio=e.pixelRatio,this._scale=e.scale,this.setChanged())}equals(e){return this.scale===e.scale&&this.pixelRatio===e.pixelRatio&&this.baseSize.equals(e.baseSize)&&this.preferredSize.equals(e.preferredSize)}setChanged(){this.dispatchEvent({type:y.EVENT_CHANGE})}get x(){return this.width}get y(){return this.height}},a(y,"EVENT_CHANGE","change"),a(y,"AUTO_SIZE",S),y),de=class Pe extends re{constructor(){super();a(this,"offset");a(this,"effectiveOffset");a(this,"_enabled");this.offset=new I,this.effectiveOffset=new I,this._enabled=!1,this.addEventListener(re.EVENT_CHANGE,()=>this.updateEffectiveOffset())}updateEffectiveOffset(){this.effectiveOffset.copy(this.offset).multiplyScalar(this.scaledPixelRatio).floor()}get enabled(){return this._enabled}set enabled(e){this._enabled!==e&&(this._enabled=e,this.setChanged())}get offsetX(){return this.effectiveOffset.x}get offsetY(){return this.effectiveOffset.y}setOffset(e,s){(this.offset.x!==e||this.offset.y!==s)&&(this.offset.set(e,s),this.updateEffectiveOffset(),this.setChanged())}set(e,s,r,n){r===void 0||n===void 0?super.setPreferredSize(e,s):(this.offset.set(e,s),this.updateEffectiveOffset(),super.setPreferredSize(r,n))}copy(e){e instanceof Pe?this.equals(e)||(this.enabled=e.enabled,this.offset.copy(e.offset),this.effectiveOffset.copy(e.effectiveOffset),super.copy(e)):super.copy(e)}equals(e){return this.enabled===e.enabled&&this.offset.equals(e.offset)&&super.equals(e)}get x(){return this.effectiveOffset.x}get y(){return this.effectiveOffset.y}get z(){return this.width}get w(){return this.height}},_e=class extends de{},Be=new I,R,v=(R=class extends x{constructor(e){super();a(this,"id");a(this,"previousDefines");a(this,"previousUniforms");a(this,"fullscreenScene");a(this,"fullscreenCamera");a(this,"screen");a(this,"_name");a(this,"_enabled");a(this,"_attached");a(this,"_timer");a(this,"_renderer");a(this,"_scene");a(this,"_camera");a(this,"_subpasses");a(this,"disposables");a(this,"materials");a(this,"resolution");a(this,"viewport");a(this,"scissor");a(this,"input");a(this,"output");this.previousDefines=new Map,this.previousUniforms=new Map,this.fullscreenScene=null,this.fullscreenCamera=null,this.screen=null,this._name=e,this._enabled=!0,this._attached=!1,this._renderer=null,this._timer=null,this._scene=null,this._camera=null,this._subpasses=[],this.id=R.idManager.getNextId(),this.disposables=new Set,this.materials=new Set,this.resolution=new re,this.viewport=new de,this.scissor=new _e,this.resolution.addEventListener(re.EVENT_CHANGE,s=>this.handleResolutionEvent(s)),this.viewport.addEventListener(de.EVENT_CHANGE,s=>this.handleViewportEvent(s)),this.scissor.addEventListener(_e.EVENT_CHANGE,s=>this.handleScissorEvent(s)),this.input=new se,this.output=new fe,this.input.addEventListener(se.EVENT_CHANGE,s=>this.handleInputEvent(s)),this.output.addEventListener(fe.EVENT_CHANGE,s=>this.handleOutputEvent(s))}get name(){return this._name}set name(e){this._name=e}get enabled(){return this._enabled}set enabled(e){this._enabled!==e&&(this._enabled=e,this.dispatchEvent({type:R.EVENT_TOGGLE}))}get attached(){return this._attached}set attached(e){this._attached!==e&&(this._attached=e,this.input.setChanged(),this.output.setChanged(),this.resolution.setChanged())}get subpasses(){return this._subpasses}set subpasses(e){for(const s of this.subpasses)s.attached=!1;for(const s of e)if(s.attached)throw new Error(`${s.name} is already attached to another pass`);this._subpasses=e,Object.freeze(this._subpasses),this.initializeSubpasses()}get timer(){return this._timer}set timer(e){this._timer=e;for(const s of this.subpasses)s.timer=e}get renderer(){return this._renderer}set renderer(e){this._renderer=e;try{(e==null?void 0:e.capabilities)!==void 0&&this.checkRequirements(e)}catch(s){console.warn(s),console.info("Disabling pass:",this),this.enabled=!1}for(const s of this.subpasses)s.renderer=e}get scene(){return this._scene}set scene(e){this._scene=e;for(const s of this.subpasses)s.scene=e}get camera(){return this._camera}set camera(e){this._camera=e,e!==null&&this.fullscreenMaterial instanceof F&&this.fullscreenMaterial.copyCameraSettings(e);for(const s of this.subpasses)s.camera=e}get fullscreenMaterial(){var e;return(e=this.screen)==null?void 0:e.material}set fullscreenMaterial(e){this.screen!==null?this.screen.material=e:(this.screen=new oe(R.fullscreenGeometry,e),this.screen.frustumCulled=!1,this.fullscreenScene=new Ue,this.fullscreenCamera=new tt(-1,1,1,-1,0,1),this.fullscreenScene.add(this.screen),this.materials.add(e))}initializeSubpasses(){for(const e of this.subpasses)e.timer=this.timer,e.renderer=this.renderer,e.scene=this.scene,e.camera=this.camera,e.resolution.copy(this.resolution),e.viewport.copy(this.viewport),e.scissor.copy(this.scissor),e.attached=!0}updateSubpassResolution(){const{baseWidth:e,baseHeight:s,scaledPixelRatio:r}=this.resolution;for(const n of this.subpasses)n.resolution.pixelRatio=r,n.resolution.setBaseSize(e,s)}updateSubpassViewport(){const{baseWidth:e,baseHeight:s,scaledPixelRatio:r}=this.viewport;for(const n of this.subpasses)n.viewport.pixelRatio=r,n.viewport.setBaseSize(e,s)}updateSubpassScissor(){const{baseWidth:e,baseHeight:s,scaledPixelRatio:r}=this.scissor;for(const n of this.subpasses)n.scissor.pixelRatio=r,n.scissor.setBaseSize(e,s)}updateOutputBufferSize(){var e,s;(s=(e=this.output.defaultBuffer)==null?void 0:e.value)==null||s.setSize(this.resolution.width,this.resolution.height)}updateViewportAndScissor(){const{baseWidth:e,baseHeight:s,scaledPixelRatio:r}=this.resolution;this.viewport.pixelRatio=r,this.viewport.setBaseSize(e,s),this.scissor.pixelRatio=r,this.scissor.setBaseSize(e,s)}updateFullscreenMaterialInput(){var s;const e=this.fullscreenMaterial;if(e instanceof st||e instanceof le){e instanceof F?e.inputBuffer=((s=this.input.defaultBuffer)==null?void 0:s.value)??null:this.input.frameBufferPrecisionHigh?e.defines.FRAME_BUFFER_PRECISION_HIGH=!0:delete e.defines.FRAME_BUFFER_PRECISION_HIGH;for(const r of this.previousDefines.keys())delete e.defines[r];for(const r of this.previousUniforms.keys())delete e.uniforms[r];this.previousDefines.clear(),this.previousUniforms.clear();for(const r of this.input.defines)this.previousDefines.set(r[0],r[1]),e.defines[r[0]]=r[1];for(const r of this.input.uniforms)this.previousUniforms.set(r[0],r[1]),e.uniforms[r[0]]=r[1];e.needsUpdate=!0}}updateFullscreenMaterialOutput(){this.fullscreenMaterial instanceof F&&(this.fullscreenMaterial.outputPrecision=this.output.frameBufferPrecisionHigh?"mediump":"lowp")}isConvolutionPass(e){const s=this.fullscreenMaterial;if(s instanceof F&&/texture\s*\(\s*gBuffer.color/.test(s.fragmentShader))return!0;if(e){for(const r of this.subpasses)if(r.isConvolutionPass(e))return!0}return!1}checkRequirements(e){}onInputChange(){}onOutputChange(){}onResolutionChange(){}onViewportChange(){}onScissorChange(){}async compile(){if(this.renderer===null)return;const e=this.fullscreenMaterial;for(const r of this.materials)this.fullscreenMaterial=r,await this.renderer.compileAsync(this.fullscreenScene,this.fullscreenCamera);e!==void 0&&(this.fullscreenMaterial=e);const s=[];for(const r of this.subpasses)s.push(r.compile());await Promise.all(s)}createFramebuffer(){const{width:e,height:s}=this.resolution;return new ye(e,s,{depthBuffer:!1})}setChanged(){this.dispatchEvent({type:R.EVENT_CHANGE})}applyViewport(e=null){const s=this.renderer;if(s===null)return;const r=this.viewport;if(r.enabled)e!==null?e.viewport.copy(r):s.setViewport(r.x,r.y,r.z,r.w);else if(e!==null){const{width:n,height:o}=e;e.viewport.set(0,0,n,o)}else{const{width:n,height:o}=s.getSize(Be);s.setViewport(0,0,n,o)}}applyScissor(e=null){const s=this.renderer;if(s===null)return;const r=this.scissor;if(r.enabled)e!==null?(e.scissor.copy(r),e.scissorTest=!0):(s.setScissor(r.x,r.y,r.z,r.w),s.setScissorTest(!0));else if(e!==null){const{width:n,height:o}=e;e.scissor.set(0,0,n,o),e.scissorTest=!1}else if(s.getScissorTest()){const{width:n,height:o}=s.getSize(Be);s.setScissor(0,0,n,o),s.setScissorTest(!1)}}setRenderTarget(e=null,s,r){var n;this.applyViewport(e),this.applyScissor(e),(n=this.renderer)==null||n.setRenderTarget(e,s,r)}renderFullscreen(){this.renderer!==null&&this.fullscreenMaterial!==null&&this.renderer.render(this.fullscreenScene,this.fullscreenCamera)}handleResolutionEvent(e){if(this.attached)switch(e.type){case"change":this.updateOutputBufferSize(),this.onResolutionChange(),this.updateSubpassResolution(),this.updateViewportAndScissor();break}}handleViewportEvent(e){if(this.attached)switch(e.type){case"change":this.onViewportChange(),this.updateSubpassViewport();break}}handleScissorEvent(e){if(this.attached)switch(e.type){case"change":this.onScissorChange(),this.updateSubpassScissor();break}}handleInputEvent(e){if(this.attached)switch(e.type){case"change":this.updateFullscreenMaterialInput(),this.onInputChange();break}}handleOutputEvent(e){if(this.attached)switch(e.type){case"change":this.updateOutputBufferSize(),this.updateFullscreenMaterialOutput(),this.onOutputChange();break}}dispose(){this.input.dispose(),this.output.dispose(),this.previousDefines.clear(),this.previousUniforms.clear();for(const e of this.materials)e==null||e.dispose();for(const e of this.disposables)e.dispose();for(const e of this.subpasses)e.dispose()}},a(R,"EVENT_CHANGE","change"),a(R,"EVENT_TOGGLE","toggle"),a(R,"fullscreenGeometry",(()=>{const e=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),s=new Ke;return s.setAttribute("position",new et(e,3)),s})()),a(R,"idManager",new ce),R),Ce=class extends le{constructor(){super({name:"BackgroundMaterial",fragmentShader:_.background.fragmentShader,vertexShader:_.background.vertexShader,uniforms:Fe.clone(_.background.uniforms),depthWrite:!1,depthTest:!1,fog:!1})}get map(){return this.uniforms.t2D.value}set map(i){this.uniforms.t2D.value=i}},Re=class extends le{constructor(){super({name:"SkyBoxMaterial",fragmentShader:_.backgroundCube.fragmentShader,vertexShader:_.backgroundCube.vertexShader,uniforms:Fe.clone(_.backgroundCube.uniforms),side:gt,depthWrite:!1,depthTest:!1,fog:!1})}get envMap(){return this.uniforms.envMap.value}set envMap(i){this.uniforms.envMap.value=i}},Mt=new Map([[vt,"highp"],[he,"mediump"],[Y,"lowp"]]),Tt=new Map([[Et,"float"],[_t,"vec2"],[Bt,"vec4"],[ee,"vec4"]]);function me(i){const t=new Map;for(let e=0,s=i.textures.length;e<s;++e){const r=i.textures[e];t.set(r.name,e)}return t}function Ge(i){const t=[];for(let e=0,s=i.textures.length;e<s;++e){const r=i.textures[e],n=Mt.get(r.type),o=Tt.get(r.format),u=r.name.replace(/\W*/g,"");e===0&&t.push("#ifndef gl_FragColor"),t.push(`layout(location = ${e}) out ${n} ${o} out_FragData${e};`),u!==""&&t.push(`#define out_${u} out_FragData${e}`),e===0&&(t.push(`#define gl_FragColor out_FragData${e}`),t.push("#endif"))}return t.join(`
`)}var L=new ft,bt=new lt,At=class extends rt{constructor(){super();a(this,"skyBox");a(this,"background");const t=new oe(new it(1,1,1),new Re);t.name="SkyBox",t.geometry.deleteAttribute("normal"),t.geometry.deleteAttribute("uv"),t.matrixAutoUpdate=!1,t.frustumCulled=!1,t.layers.enableAll(),this.skyBox=t,t.onBeforeRender=function(s,r,n){this.matrixWorld.copyPosition(n.matrixWorld)};const e=new oe(new nt(2,2),new Ce);e.name="Background",e.geometry.deleteAttribute("normal"),e.matrixAutoUpdate=!1,e.frustumCulled=!1,e.layers.enableAll(),this.background=e,this.add(this.skyBox,this.background)}setClearValues(t){const e=new Re,s=new Ce,r=new Map,n=[],o=[];for(const l of t.gBuffer)r.set(`pp_${l[0]}`,new E(l[1])),n.push(`uniform vec4 pp_${l[0]};`),o.push(`	#ifdef out_${l[0]}
		out_${l[0]} = pp_${l[0]};
#endif`);const u=n.join(`
`),f=o.join(`
`);for(const l of[e,s]){l.fragmentShader=l.fragmentShader.replace(/(void main\(\) {)/,`${u}
$1
${f}
`);for(const c of r)l.uniforms[c[0]]=c[1];l.onBeforeCompile=(c,h)=>{const p=h.getRenderTarget();if(p===null)return;const m=Ge(p);c.fragmentShader=m+`

`+c.fragmentShader}}this.skyBox.material.dispose(),this.background.material.dispose(),this.skyBox.material=e,this.background.material=s}update(t){const{skyBox:e,background:s}=this;if(e.visible=!1,s.visible=!1,!(t===null||!(t.background instanceof at)))if(t.background instanceof ot||t.background.mapping===ut){const r=t.background.isRenderTargetTexture?1:-1;L.copy(t.backgroundRotation),L.x*=-1,L.y*=-1,L.z*=-1,L.y*=r,L.z*=r,e.material.envMap=t.background,e.material.uniforms.flipEnvMap.value=r,e.material.uniforms.backgroundBlurriness.value=t.backgroundBlurriness,e.material.uniforms.backgroundIntensity.value=t.backgroundIntensity,e.material.uniforms.backgroundRotation.value.setFromMatrix4(bt.makeRotationFromEuler(L)),e.visible=!0}else s.material.map=t.background,s.material.uniforms.backgroundIntensity.value=t.backgroundIntensity,s.visible=!0}dispose(){this.skyBox.material.dispose(),this.background.material.dispose()}},xt=class{constructor(i=!0,t=!0,e=!0){a(this,"gBuffer");a(this,"depth");a(this,"stencil");const s=new Set;s.add("Normal"),s.add("ORM"),s.add("Emission"),this.gBuffer=s,this.color=i,this.depth=t,this.stencil=e}get color(){return this.gBuffer.has("Color")}set color(i){i?this.gBuffer.add("Color"):this.gBuffer.delete("Color")}},z,Se=(z=class extends x{constructor(){super();a(this,"_color");a(this,"_alpha");a(this,"gBuffer");this._color=null,this._alpha=null;const e=new d([["Normal",new q(.5,.5,1,1)],["ORM",new q(1,0,0,1)],["Emission",new q(0,0,0,1)]]);e.addEventListener(d.EVENT_CHANGE,()=>this.setChanged()),this.gBuffer=e}get color(){return this._color}set color(e){this._color=e,this.setChanged()}get alpha(){return this._alpha}set alpha(e){this._alpha=e,this.setChanged()}setChanged(){this.dispatchEvent({type:z.EVENT_CHANGE})}},a(z,"EVENT_CHANGE","change"),z),Me=new pe,K=new Float32Array(4),ae=class extends v{constructor(t=!0,e=!0,s=!0){super("ClearPass");a(this,"clearFlags");a(this,"clearValues");a(this,"gBufferIndices");a(this,"background");a(this,"backgroundScene");this.clearFlags=new xt(t,e,s),this.clearValues=new Se,this.gBufferIndices=null,this.background=new At,this.background.setClearValues(this.clearValues),this.clearValues.addEventListener(Se.EVENT_CHANGE,()=>this.background.setClearValues(this.clearValues)),this.backgroundScene=new Ue,this.backgroundScene.add(this.background),this.disposables.add(this.background)}clearGBuffer(){if(this.renderer===null||this.gBufferIndices===null)return;const t=this.clearFlags,e=this.clearValues,s=this.gBufferIndices,r=this.renderer.getContext();for(const n of e.gBuffer){const o=s.get(n[0]);if(!t.gBuffer.has(n[0])||o===void 0)continue;const u=n[1];K[0]=u.x,K[1]=u.y,K[2]=u.z,K[3]=u.w,r.clearBufferfv(r.COLOR,o,K)}}clear(t=this.clearValues.color){const e=this.renderer,s=this.clearFlags,r=this.clearValues.alpha,n=t!==null,o=r!==null,u=e.getClearAlpha();n&&(e.getClearColor(Me),e.setClearColor(t)),o&&e.setClearAlpha(r),e.clear(s.color,s.depth,s.stencil),n?e.setClearColor(Me,u):o&&e.setClearAlpha(u),this.clearGBuffer()}clearWithBackground(){const t=this.scene,e=this.camera,s=this.renderer,r=this.clearFlags;t.background instanceof pe?this.clear(t.background):((r.depth||r.stencil)&&s.clear(!1,r.depth,r.stencil),this.background.update(t),s.render(this.backgroundScene,e))}onOutputChange(){var e;const t=((e=this.output.defaultBuffer)==null?void 0:e.value)??null;this.gBufferIndices=t!==null?me(t):null}async compile(){this.renderer===null||this.camera===null||await Promise.all([super.compile(),this.renderer.compileAsync(this.backgroundScene,this.camera)])}render(){var s,r;if(this.renderer===null)return;const t=((s=this.scene)==null?void 0:s.background)??null,e=this.clearValues.color!==null;this.setRenderTarget((r=this.output.defaultBuffer)==null?void 0:r.value),!e&&this.camera!==null&&t!==null?this.clearWithBackground():this.clear()}},P,wt=(P=class extends Set{constructor(e,s=P.idManager.getNextId()){super();a(this,"_layer");a(this,"enabled");a(this,"exclusive");this._layer=s,(this._layer<1||this._layer>31)&&(console.warn("Layer out of range, resetting to 2"),P.idManager.reset(2),this._layer=P.idManager.getNextId()),this.enabled=!0,this.exclusive=!1,e!==void 0&&this.set(e)}get layer(){return this._layer}set layer(e){const s=this._layer;for(const r of this)r.layers.disable(s),r.layers.enable(e);this._layer=e}clear(){const e=this.layer;for(const s of this)s.layers.disable(e);super.clear()}add(e){return this.exclusive?e.layers.set(this.layer):e.layers.enable(this.layer),super.add(e)}delete(e){return this.has(e)&&e.layers.disable(this.layer),super.delete(e)}set(e){this.clear();for(const s of e)this.add(s);return this}toggle(e){let s;return this.has(e)?(this.delete(e),s=!1):(this.add(e),s=!0),s}setVisible(e){for(const s of this)e?s.layers.enable(0):s.layers.disable(0);return this}},a(P,"idManager",new ce(2)),P),Nt=`#include <common>
#include <pp_default_output_pars_fragment>
#ifdef COLOR_WRITE
#include <dithering_pars_fragment>
#include <pp_input_buffer_pars_fragment>
#endif
#ifdef DEPTH_WRITE
#include <pp_depth_buffer_pars_fragment>
#endif
in vec2 vUv;void main(){
#ifdef COLOR_WRITE
out_Color=texture(inputBuffer,vUv);
#ifdef COLOR_SPACE_CONVERSION
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
#else
out_Color=vec4(0.0);
#endif
#ifdef DEPTH_WRITE
gl_FragDepth=texture(depthBuffer,vUv).r;
#endif
}`,Ie="out vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",Ut=class extends F{constructor(){super({name:"CopyMaterial",fragmentShader:Nt,vertexShader:Ie,defines:{COLOR_SPACE_CONVERSION:!0,COLOR_WRITE:!0},uniforms:{depthBuffer:new E(null)}}),this.depthFunc=mt}get inputBuffer(){return super.inputBuffer}set inputBuffer(i){const t=i!==null;this.colorWrite!==t&&(t?this.defines.COLOR_WRITE=!0:delete this.defines.COLOR_WRITE,this.colorWrite=t,this.needsUpdate=!0),super.inputBuffer=i}get depthBuffer(){return this.uniforms.depthBuffer.value}set depthBuffer(i){const t=i!==null;this.depthWrite!==t&&(t?this.defines.DEPTH_WRITE=!0:delete this.defines.DEPTH_WRITE,this.depthTest=t,this.depthWrite=t,this.needsUpdate=!0),this.uniforms.depthBuffer.value=i}get colorSpaceConversion(){return this.defines.COLOR_SPACE_CONVERSION!==void 0}set colorSpaceConversion(i){this.colorSpaceConversion!==i&&(i?this.defines.COLOR_SPACE_CONVERSION=!0:delete this.defines.COLOR_SPACE_CONVERSION,this.needsUpdate=!0)}},yt=class extends v{constructor(i){super("CopyPass"),this.output.defaultBuffer=i??this.createFramebuffer(),this.fullscreenMaterial=new Ut}get renderer(){return super.renderer}set renderer(i){super.renderer=i,this.initializeOutputBuffer()}initializeOutputBuffer(){var t;const i=((t=this.output.defaultBuffer)==null?void 0:t.value)??null;this.renderer!==null&&i!==null&&this.renderer.initRenderTarget(i)}onInputChange(){this.fullscreenMaterial.depthBuffer=this.input.getBuffer("Depth")}onOutputChange(){this.initializeOutputBuffer()}onResolutionChange(){this.initializeOutputBuffer()}blit(){var r,n;const i=((r=this.input.defaultBuffer)==null?void 0:r.value)??null,t=((n=this.output.defaultBuffer)==null?void 0:n.value)??null;if(this.renderer===null||i===null||t===null)return!1;const e=i.source.data;if(e.width!==t.width||e.height!==t.height)return!1;i.type===t.texture.type&&i.format===t.texture.format&&this.renderer.copyTextureToTexture(i,t.texture);const s=this.input.getBuffer("Depth");return s!==null&&t.depthTexture!==null&&s!==t.depthTexture&&s.type===t.depthTexture.type&&s.format===t.depthTexture.format&&this.renderer.copyTextureToTexture(s,t.depthTexture),!0}render(){var t,e;const i=((t=this.input.defaultBuffer)==null?void 0:t.value)??null;this.renderer===null||i===null||this.blit()||(this.setRenderTarget((e=this.output.defaultBuffer)==null?void 0:e.value),this.renderFullscreen())}},ie=class extends v{constructor(t,e,{stencilBuffer:s=!1,depthBuffer:r=!0,frameBufferType:n=he,samples:o=0,gBufferConfig:u=new Q}={}){super("GeometryPass");a(this,"selection");a(this,"onChildAdded");a(this,"onChildRemoved");a(this,"gBufferConfig");a(this,"registeredMaterials");a(this,"copyPass");a(this,"gBufferComponents");a(this,"stencilBuffer");a(this,"depthBuffer");a(this,"frameBufferType");a(this,"gBufferResource");a(this,"_samples");this.onChildAdded=l=>{var c;(c=l.child)==null||c.traverse(h=>{h.addEventListener("childadded",this.onChildAdded),h.addEventListener("childremoved",this.onChildRemoved),this.updateMaterial(h)})},this.onChildRemoved=l=>{var c;(c=l.child)==null||c.traverse(h=>{h.removeEventListener("childadded",this.onChildAdded),h.removeEventListener("childremoved",this.onChildRemoved)})},this.stencilBuffer=s,this.depthBuffer=r,this.frameBufferType=n,this._samples=o,this.selection=new wt,this.selection.enabled=!1,this.gBufferConfig=u,this.registeredMaterials=new WeakSet,this.copyPass=new yt,this.copyPass.enabled=!1,this.subpasses=[this.copyPass];const f=new ue;f.addEventListener(ue.EVENT_CHANGE,()=>this.updateGBuffer()),this.gBufferComponents=f,this.gBufferResource=new J,this.output.defaultBuffer=this.gBufferResource,this.scene=t,this.camera=e,this.updateTextureConfigs(),this.updateGBuffer()}get scene(){return super.scene}set scene(t){this.onChildRemoved({child:this.scene}),super.scene=t,this.onChildAdded({child:t})}get samples(){return this._samples}set samples(t){var s;this._samples=t;const e=((s=this.output.defaultBuffer)==null?void 0:s.value)??null;e!==null&&e.samples!==t&&(e.samples=t,e.dispose())}get gBuffer(){return this.gBufferResource.value}get textureConfigs(){return Array.from(this.gBufferConfig.textureConfigs).filter(t=>this.gBufferComponents.has(t[0]))}get renderer(){return super.renderer}set renderer(t){super.renderer=t,this.updateOutputBufferColorSpace()}updateTextureConfigs(){const t=this.gBufferConfig.textureConfigs;t.set("Color",{minFilter:j,magFilter:j,type:this.frameBufferType,format:ee,isColorBuffer:!0}),t.set("Normal",{minFilter:Ee,magFilter:Ee,type:he,format:ee,isColorBuffer:!1}),t.set("ORM",{minFilter:j,magFilter:j,type:Y,format:ee,isColorBuffer:!1}),t.set("Emission",{minFilter:j,magFilter:j,type:this.frameBufferType,format:ee,isColorBuffer:!0})}updateMaterial(t){if(!(t instanceof oe))return;const e=t;for(const s of Array.isArray(e.material)?e.material:[e.material]){if(this.registeredMaterials.has(s))return;this.registeredMaterials.add(s);const r=s.onBeforeCompile;s.onBeforeCompile=(n,o)=>{if(s.onBeforeCompile!==r&&r.call(s,n,o),this.gBuffer===null)return;const u=Ge(this.gBuffer);n.fragmentShader=u+`

`+n.fragmentShader}}}updateOutputBufferColorSpace(){const t=this.gBuffer,e=this.renderer;if(t===null||e===null)return;const s=me(t),n=this.frameBufferType===Y&&e.outputColorSpace===Z?Z:H;for(const o of this.textureConfigs)if(o[1].isColorBuffer&&s.has(o[0])){const u=s.get(o[0]);t.textures[u].colorSpace=n}}updateGBuffer(){var u,f,l;const t=this.output,e=this.gBufferComponents;if(t.hasDefaultBuffer&&t.defaultBuffer!==this.gBufferResource)return;if(t.hasDefaultBuffer||(t.defaultBuffer=this.gBufferResource),(f=(u=t.defaultBuffer.value)==null?void 0:u.depthTexture)==null||f.dispose(),(l=t.defaultBuffer.value)==null||l.dispose(),e.size===0){t.defaultBuffer=null,t.defines.clear();return}const{width:s,height:r}=this.resolution,n=this.textureConfigs,o=new ye(s,r,{stencilBuffer:this.stencilBuffer,depthBuffer:this.depthBuffer,samples:this.samples,count:n.length});for(let c=0,h=n.length;c<h;++c){const p=n[c],m=o.textures[c],w=p[1];m.name=p[0],m.minFilter=w.minFilter,m.magFilter=w.magFilter,m.format=w.format,m.type=w.type}t.defaultBuffer=o,this.configureDepthTexture(),this.updateOutputBufferColorSpace()}configureDepthTexture(){var r,n,o;const t=this.output;if(t.defaultBuffer!==this.gBufferResource)return;const e=t.defaultBuffer.value;if(e===null)return;if(!this.gBufferComponents.has("Depth")){(r=e.depthTexture)==null||r.dispose(),e.depthTexture=null;return}const s=this.input.getBuffer("Depth");if(s!==null)e.depthTexture!==s&&((n=e.depthTexture)==null||n.dispose(),e.depthTexture=s);else{const u=new qe(1,1);u.name="Depth",u.format=this.stencilBuffer?Ye:Ze,u.type=this.stencilBuffer?Qe:Je,(o=e.depthTexture)==null||o.dispose(),e.depthTexture=u}}updateCopyPass(){var n,o;const t=((n=this.input.defaultBuffer)==null?void 0:n.value)??null,e=((o=this.output.defaultBuffer)==null?void 0:o.value)??null,s=t===(e==null?void 0:e.texture),r=((e==null?void 0:e.textures.length)??0)>1;this.copyPass.enabled=t!==null&&!s&&!r}onInputChange(){this.configureDepthTexture();const t=this.copyPass;t.input.defaultBuffer=this.input.defaultBuffer,this.updateCopyPass(),this.input.buffers.has("Depth")?t.input.buffers.set("Depth",this.input.buffers.get("Depth")):t.input.buffers.delete("Depth")}onOutputChange(){this.output.hasDefaultBuffer?this.configureDepthTexture():this.updateGBuffer(),this.copyPass.output.defaultBuffer=this.output.defaultBuffer,this.updateCopyPass()}onResolutionChange(){this.copyPass.resolution.copy(this.resolution)}async compile(){if(this.renderer===null||this.scene===null||this.camera===null)return;const t=[];t.push(super.compile()),t.push(this.renderer.compileAsync(this.scene,this.camera)),await Promise.all(t)}render(){var o;const{renderer:t,scene:e,camera:s}=this;if(t===null||e===null||s===null)return;const r=s.layers.mask,n=e.background;e.background=null,this.selection.enabled&&s.layers.set(this.selection.layer),this.copyPass.enabled&&this.copyPass.render(),this.setRenderTarget((o=this.output.defaultBuffer)==null?void 0:o.value),t.render(e,s),s.layers.mask=r,e.background=n}};function Oe(i,t){for(const e of i.input.buffers.values())t.add(e);for(const e of i.output.buffers.values())t.add(e);for(const e of i.subpasses)Oe(e,t)}var Ft=class{constructor(i){a(this,"pipelines");a(this,"activeResources");this.pipelines=i,this.activeResources=new Set}gatherResources(){const i=new Set;for(const t of this.pipelines)for(const e of t.passes)Oe(e,i);return i}optimize(){const i=this.gatherResources();for(const t of this.activeResources)t instanceof ge&&!i.has(t)&&t.dispose();this.activeResources=i}},Dt=class X{constructor(){a(this,"pipelines");a(this,"resourceManager");a(this,"outputDefaultBuffers");a(this,"updating");this.pipelines=new Set,this.resourceManager=new Ft(this.pipelines),this.outputDefaultBuffers=new WeakMap,this.updating=!1}updateInput(t){const e=X.findMainGeometryPass(t),s=t.passes.filter(n=>n.enabled);for(let n=0,o=1,u=s.length;n<u;++n,++o){const f=s[n];if(f!==e){if(o<u&&f instanceof ae){const l=s[o];f.scene=l.scene,f.camera=l.camera}else!(f instanceof ie)&&e!==void 0&&(f.scene=e.scene,f.camera=e.camera);X.assignGBufferTextures(f,e)}}let r;for(let n=0,o=1,u=s.length;o<u;++n,++o){const f=s[n],l=s[o];!(f instanceof ae)&&f.output.hasDefaultBuffer&&f.output.defaultBuffer.value!==null&&(r=f.output.defaultBuffer),f.output.defines.forEach((c,h)=>l.input.defines.set(h,c)),f.output.uniforms.forEach((c,h)=>l.input.uniforms.set(h,c)),r===void 0?l.input.buffers.delete(se.BUFFER_DEFAULT):r!==void 0&&(l.input.defaultBuffer=r.texture)}}restoreOutputBuffers(t){const e=this.outputDefaultBuffers;for(const s of t)if(s.output.defaultBuffer!==null&&e.has(s.output.defaultBuffer)){const r=e.get(s.output.defaultBuffer);e.delete(s.output.defaultBuffer),s.output.defaultBuffer=r}}updateOutput(t){const e=t.passes.filter(s=>s.enabled);if(t.autoRenderToScreen&&e.length>0){this.restoreOutputBuffers(e);const s=this.outputDefaultBuffers,r=e[e.length-1];r.output.defaultBuffer!==null&&(s.set(r.output.defaultBuffer,r.output.defaultBuffer.value),r.output.defaultBuffer=null)}for(let s=0,r=1,n=e.length;r<n;++s,++r){const o=e[s];if(o instanceof ae){const u=e[r];u.output.defines.forEach((f,l)=>o.output.defines.set(l,f)),u.output.uniforms.forEach((f,l)=>o.output.uniforms.set(l,f)),o.output.defaultBuffer=u.output.defaultBuffer}}}addPipeline(t){this.pipelines.add(t)}removePipeline(t){this.pipelines.delete(t)}updatePipeline(t){X.gatherGBufferComponents(t),this.updateOutput(t),this.updateInput(t),X.syncDefaultBufferType(t)}update(){if(!this.updating){this.updating=!0;for(const t of this.pipelines)this.updatePipeline(t);this.resourceManager.optimize(),this.updating=!1}}static syncDefaultBufferType(t){var e,s,r;for(const n of t.passes.filter(o=>o.enabled)){const o=((e=n.input.defaultBuffer)==null?void 0:e.value)??null,u=((s=n.output.defaultBuffer)==null?void 0:s.value)??null;o===null||u===null||n instanceof ie||(u.texture.format=o.format,u.texture.internalFormat=o.internalFormat,u.texture.type=o.type,!n.input.frameBufferPrecisionHigh&&((r=t.renderer)==null?void 0:r.outputColorSpace)===Z&&(u.texture.colorSpace=Z))}}static findMainGeometryPass(t){return t.passes.find(e=>e.enabled&&e instanceof ie)}static gatherGBufferComponents(t){const e=X.findMainGeometryPass(t);if(e===void 0)return;e.gBufferComponents.clear();for(const r of t.passes.filter(n=>n.enabled))for(const n of r.input.gBuffer)e.gBufferComponents.add(n);const s=t.passes.filter(r=>r.enabled&&r instanceof ie);if(!(s.length<=1||!e.gBufferComponents.has("Color")))for(let r=1,n=s.length;r<n;++r){const o=s[r];o.gBufferComponents.add("Color"),o.depthBuffer&&(o.gBufferComponents.add("Depth"),o.input.gBuffer.add("Depth"),e.gBufferComponents.add("Depth"))}}static assignGBufferTextures(t,e){if(e===void 0||e.gBuffer===null)return;t.input.gBufferConfig=e.gBufferConfig;const s=me(e.gBuffer);for(const r of t.input.gBuffer)if(r==="Depth")t.input.buffers.set(r,new te(e.gBuffer.depthTexture));else if(s.has(r)){const n=s.get(r);t.input.buffers.set(r,new te(e.gBuffer.textures[n]))}}},Pt=`uniform mat4 projectionMatrix;uniform mat4 projectionMatrixInverse;uniform vec3 cameraParams;
#define CAMERA_NEAR cameraParams.x
#define CAMERA_FAR cameraParams.y
#define CAMERA_ASPECT cameraParams.z
#ifdef PERSPECTIVE_CAMERA
#define getViewZ(depth) perspectiveDepthToViewZ(depth, cameraParams.x, cameraParams.y)
#else
#define getViewZ(depth) orthographicDepthToViewZ(depth, cameraParams.x, cameraParams.y)
#endif
vec3 getViewPosition(const in vec2 screenPosition,const in float depth,const in float viewZ){vec4 clipPosition=vec4(vec3(screenPosition,depth)*2.0-1.0,1.0);float clipW=projectionMatrix[2][3]*viewZ+projectionMatrix[3][3];clipPosition*=clipW;return(projectionMatrixInverse*clipPosition).xyz;}vec3 getViewPosition(const in vec2 screenPosition,const in float depth){return getViewPosition(screenPosition,depth,getViewZ(depth));}`,Gt="vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}",It=`#ifndef gl_FragColor
layout(location=0)out OUTPUT_COLOR_PRECISION vec4 out_FragData0;
#define gl_FragColor out_FragData0
#ifndef out_Color
#define out_Color out_FragData0
#endif
#endif
`,Ot=`#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
`,Lt=`#ifdef GL_FRAGMENT_PRECISION_HIGH
#define DEPTH_BUFFER_PRECISION highp
#else
#define DEPTH_BUFFER_PRECISION mediump
#endif
`,Ht=`float readDepth(sampler2D depthBuffer,const in vec2 uv,const in float near,const in float far){float depth=texture(depthBuffer,uv).r;
#ifdef LOG_DEPTH
float d=pow(2.0,depth*log2(far+1.0))-1.0;float a=far/(far-near);float b=far*near/(near-far);depth=a+b/d;
#endif
return depth;}
#if defined(CAMERA_NEAR) && defined(CAMERA_FAR)
#define readDepth(depthBuffer, uv) readDepth(depthBuffer, uv, CAMERA_NEAR, CAMERA_FAR);
#endif
`,Vt=`#ifdef FRAME_BUFFER_PRECISION_HIGH
#define FRAME_BUFFER_PRECISION mediump
#else
#define FRAME_BUFFER_PRECISION lowp
#endif
`,zt=`#ifdef FRAME_BUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
`,$t="uniform vec4 resolution;",kt=`uniform mat4 viewMatrixInverse;
#define getWorldPosition(viewPosition) (viewMatrixInverse * vec4(viewPosition, 1.0)).xyz
#define getDistance(worldPosition) length(worldPosition - cameraPosition)
`,Wt=`#ifdef out_Normal
out_Normal=vec4(0.0);
#endif
#ifdef out_ORM
out_ORM=vec4(0.0);
#endif
#ifdef out_Emission
out_Emission=vec4(0.0);
#endif
`,jt=`#ifdef out_Normal
out_Normal=vec4(normal,1.0);
#endif
`,Xt=`#ifdef out_ORM
#ifdef USE_AOMAP
out_ORM.x=ambientOcclusion;
#else
out_ORM.x=1.0;
#endif
#endif
`,qt=`#ifdef out_ORM
out_ORM.y=roughnessFactor;
#endif
`,Yt=`#ifdef out_ORM
out_ORM.z=metalnessFactor;
#endif
`,Zt=`#ifdef out_Emission
out_Emission=vec4(totalEmissiveRadiance,1.0);
#endif
`,Qt=class{static register(){if(Object.hasOwn(O,"pp_extensions"))return;Object.assign(O,{pp_extensions:null,pp_camera_pars_fragment:Pt,pp_colorspace_conversion_pars_fragment:Gt,pp_default_output_pars_fragment:It,pp_default_output_fragment:Wt,pp_depth_buffer_pars_fragment:Ot,pp_depth_buffer_precision_pars_fragment:Lt,pp_depth_utils_pars_fragment:Ht,pp_frame_buffer_precision_pars_fragment:Vt,pp_input_buffer_pars_fragment:zt,pp_resolution_pars_fragment:$t,pp_world_utils_pars_fragment:kt}),O.normal_fragment_maps+=`
`+jt,O.aomap_fragment+=`
`+Xt,O.roughnessmap_fragment+=`
`+qt,O.metalnessmap_fragment+=`
`+Yt,O.emissivemap_fragment+=`
`+Zt,_.background.fragmentShader=_.background.fragmentShader.replace(/(#include <tonemapping_fragment>)/,`#include <pp_default_output_fragment>
$1`);const i=[_.basic,_.lambert,_.phong,_.matcap,_.points,_.dashed,_.sprite];for(const t of i)t.fragmentShader=t.fragmentShader.replace(/(#include <clipping_planes_fragment>)/,`$1

#include <pp_default_output_fragment>`)}},ne=new I,g,As=(g=class{constructor(t=null){a(this,"_timer");a(this,"_passes");a(this,"_renderer");a(this,"_autoRenderToScreen");a(this,"resolution");a(this,"updateStyle");Qt.register(),g.ioManager.addPipeline(this),this._timer=new Xe,this._passes=[],this._renderer=null,this._autoRenderToScreen=!0,this.renderer=t,this.resolution=new re,this.resolution.addEventListener("change",()=>this.onResolutionChange()),this.updateStyle=!0}get autoRenderToScreen(){return this._autoRenderToScreen}set autoRenderToScreen(t){this.autoRenderToScreen!==t&&(this._autoRenderToScreen=t,g.ioManager.update())}get renderer(){return this._renderer}set renderer(t){this._renderer=t;for(const e of this.passes)e.renderer=t;t!==null&&(t.autoClear=!1,this.passes.length>0&&(this.onResolutionChange(),g.ioManager.update()))}get timer(){return this._timer}get passes(){return this._passes}registerPass(t){g.registeredPasses.add(t),this.renderer!==null&&(this.renderer.getDrawingBufferSize(ne),t.resolution.setBaseSize(ne.width,ne.height),t.viewport.copyBaseSize(this.resolution),t.scissor.copyBaseSize(this.resolution)),t.renderer=this.renderer,t.timer=this.timer,t.attached=!0,t.addEventListener(v.EVENT_TOGGLE,g.listener),t.input.addEventListener(se.EVENT_CHANGE,g.listener),t.output.addEventListener(fe.EVENT_CHANGE,g.listener)}unregisterPass(t){g.registeredPasses.delete(t),t.renderer=null,t.timer=null,t.attached=!1,t.removeEventListener(v.EVENT_TOGGLE,g.listener),t.input.removeEventListener(se.EVENT_CHANGE,g.listener),t.output.removeEventListener(fe.EVENT_CHANGE,g.listener)}add(...t){for(const e of t){if(g.registeredPasses.has(e))throw new Error(`The pass "${e.name}" has already been added to a pipeline`);this.registerPass(e),this._passes.push(e)}g.ioManager.update()}remove(...t){let e=!1;for(const s of t){const r=this._passes,n=r.indexOf(s);n!==-1&&r.splice(n,1).length>0&&(this.unregisterPass(s),e=!0)}e&&g.ioManager.update()}removeAllPasses(){for(const t of this.passes)this.unregisterPass(t);this._passes=[],g.ioManager.update()}onResolutionChange(){if(this.renderer===null){console.debug("Unable to update the render size because the renderer is null");return}const{baseWidth:t,baseHeight:e,scaledPixelRatio:s}=this.resolution,r=this.renderer.getSize(ne);this.renderer.getPixelRatio()!==s&&this.renderer.setPixelRatio(s),(r.width!==t||r.height!==e)&&this.renderer.setSize(t,e,this.updateStyle);for(const n of this.passes)n.resolution.pixelRatio=s,n.resolution.setBaseSize(t,e)}setPixelRatio(t){const e=this.updateStyle;this.updateStyle=!1,this.resolution.pixelRatio=t,this.updateStyle=e}setSize(t,e,s=!0){const r=this.updateStyle;this.updateStyle=!1,this.renderer!==null&&(this.resolution.pixelRatio=this.renderer.getPixelRatio()),this.updateStyle=s,this.resolution.setSize(t,e),this.updateStyle=r}setViewport(t,e=0,s=0,r=0){if(t instanceof q){const n=t;t=n.x,e=n.y,s=n.z,r=n.w}for(const n of this.passes)n.viewport.set(t,e,s,r)}setScissor(t,e=0,s=0,r=0){if(t instanceof q){const n=t;t=n.x,e=n.y,s=n.z,r=n.w}for(const n of this.passes)n.scissor.set(t,e,s,r)}async compile(){const t=[];for(const e of this.passes)t.push(e.compile());await Promise.all(t)}render(t){if(this.renderer!==null){this._timer.update(t);for(const e of this.passes)e.enabled&&e.render()}}dispose(){g.ioManager.removePipeline(this);for(const t of this.passes)t.dispose();this.removeAllPasses(),this._timer.dispose(),v.fullscreenGeometry.dispose()}},a(g,"ioManager",new Dt),a(g,"registeredPasses",new WeakSet),a(g,"listener",()=>g.ioManager.update()),g),Jt=(i=>(i[i.LINEAR=0]="LINEAR",i[i.REINHARD=1]="REINHARD",i[i.CINEON=2]="CINEON",i[i.ACES_FILMIC=3]="ACES_FILMIC",i[i.AGX=4]="AGX",i[i.NEUTRAL=5]="NEUTRAL",i[i.CUSTOM=6]="CUSTOM",i))(Jt||{}),$,Le=($=class{constructor(t,e,s=!1){a(this,"id");a(this,"name");a(this,"shader");a(this,"supportsHDR");this.id=$.idManager.getNextId(),this.name=t,this.shader=e,this.supportsHDR=s}},a($,"idManager",new ce),$),k,Kt=(k=class extends x{constructor(e,s=1){super();a(this,"_blendFunction");a(this,"opacityUniform");this._blendFunction=e,this.opacityUniform=new E(s)}get opacity(){return this.opacityUniform.value}set opacity(e){this.opacityUniform.value=e}get blendFunction(){return this._blendFunction}set blendFunction(e){this._blendFunction=e,this.dispatchEvent({type:k.EVENT_CHANGE})}},a(k,"EVENT_CHANGE","change"),k),es="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb,y.a),opacity);}",ts=class extends Le{constructor(){super("add",es,!0)}},ss="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}",rs=class extends Le{constructor(){super("src",ss,!0)}},is=`#include <common>
#include <pp_default_output_pars_fragment>
#include <pp_input_buffer_pars_fragment>
#ifdef THRESHOLD
uniform float threshold;uniform float smoothing;
#endif
in vec2 vUv;void main(){vec4 texel=texture(inputBuffer,vUv);float l=luminance(texel.rgb);
#ifdef THRESHOLD
l=smoothstep(threshold,threshold+smoothing,l)*l;
#endif
#ifdef COLOR
out_Color=vec4(texel.rgb*clamp(l,0.0,1.0),l);
#else
out_Color=vec4(l);
#endif
}`,ns=class extends F{constructor(){super({name:"LuminanceMaterial",fragmentShader:is,vertexShader:Ie,uniforms:{threshold:new E(0),smoothing:new E(0)}})}get thresholdEnabled(){return this.defines.THRESHOLD!==void 0}set thresholdEnabled(i){this.thresholdEnabled!==i&&(i?this.defines.THRESHOLD=!0:delete this.defines.THRESHOLD,this.needsUpdate=!0)}get threshold(){return this.uniforms.threshold.value}set threshold(i){this.thresholdEnabled=this.smoothing>0||i>0,this.uniforms.threshold.value=i}get smoothing(){return this.uniforms.smoothing.value}set smoothing(i){this.thresholdEnabled=this.threshold>0||i>0,this.uniforms.smoothing.value=i}get colorOutput(){return this.defines.COLOR!==void 0}set colorOutput(i){i?this.defines.COLOR=!0:delete this.defines.COLOR,this.needsUpdate=!0}},G,as=(G=class extends v{constructor(){super("LuminancePass"),this.output.setBuffer(G.BUFFER_LUMINANCE,this.createFramebuffer()),this.fullscreenMaterial=new ns}get renderTarget(){return this.output.getBuffer(G.BUFFER_LUMINANCE)}get texture(){return this.output.buffers.get(G.BUFFER_LUMINANCE).texture}onInputChange(){var s;const t=((s=this.input.defaultBuffer)==null?void 0:s.value)??null;if(t===null)return;const e=this.renderTarget.texture;e.format=t.format,e.internalFormat=t.internalFormat,e.type=t.type,e.colorSpace=t.colorSpace,this.input.frameBufferPrecisionHigh?this.fullscreenMaterial.outputPrecision="mediump":this.fullscreenMaterial.outputPrecision="lowp"}onResolutionChange(){const t=this.resolution;this.renderTarget.setSize(t.width,t.height)}render(){this.setRenderTarget(this.renderTarget),this.renderFullscreen()}},a(G,"BUFFER_LUMINANCE","BUFFER_LUMINANCE"),G),os=`#include <pp_default_output_pars_fragment>
#include <pp_input_buffer_pars_fragment>
#define WEIGHT_INNER 0.125
#define WEIGHT_OUTER 0.0555555
in vec2 vUv;in vec2 vUv00,vUv01,vUv02,vUv03;in vec2 vUv04,vUv05,vUv06,vUv07;in vec2 vUv08,vUv09,vUv10,vUv11;float clampToBorder(const in vec2 uv){
#ifdef CLAMP_TO_BORDER
return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);
#else
return 1.0;
#endif
}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture(inputBuffer,vUv00);c+=w.y*texture(inputBuffer,vUv01);c+=w.z*texture(inputBuffer,vUv02);c+=w.w*texture(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture(inputBuffer,vUv04);c+=w.y*texture(inputBuffer,vUv05);c+=w.z*texture(inputBuffer,vUv06);c+=w.w*texture(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture(inputBuffer,vUv08);c+=w.y*texture(inputBuffer,vUv09);c+=w.z*texture(inputBuffer,vUv10);c+=w.w*texture(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture(inputBuffer,vUv);out_Color=c;}`,us=`#include <pp_resolution_pars_fragment>
out vec2 vUv;out vec2 vUv00,vUv01,vUv02,vUv03;out vec2 vUv04,vUv05,vUv06,vUv07;out vec2 vUv08,vUv09,vUv10,vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+resolution.zw*vec2(-1.0,1.0);vUv01=vUv+resolution.zw*vec2(1.0,1.0);vUv02=vUv+resolution.zw*vec2(-1.0,-1.0);vUv03=vUv+resolution.zw*vec2(1.0,-1.0);vUv04=vUv+resolution.zw*vec2(-2.0,2.0);vUv05=vUv+resolution.zw*vec2(0.0,2.0);vUv06=vUv+resolution.zw*vec2(2.0,2.0);vUv07=vUv+resolution.zw*vec2(-2.0,0.0);vUv08=vUv+resolution.zw*vec2(2.0,0.0);vUv09=vUv+resolution.zw*vec2(-2.0,-2.0);vUv10=vUv+resolution.zw*vec2(0.0,-2.0);vUv11=vUv+resolution.zw*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}`,fs=class extends F{constructor({clampToBorder:i=!0}={}){super({name:"DownsamplingMaterial",fragmentShader:os,vertexShader:us,defines:{CLAMP_TO_BORDER:!0}}),this.clampToBorder=i}get clampToBorder(){return this.defines.CLAMP_TO_BORDER!==void 0}set clampToBorder(i){this.clampToBorder!==i&&(i?this.defines.CLAMP_TO_BORDER=!0:delete this.defines.CLAMP_TO_BORDER,this.needsUpdate=!0)}},ls=`#include <pp_default_output_pars_fragment>
#include <pp_input_buffer_pars_fragment>
#ifdef USE_SUPPORT_BUFFER
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D supportBuffer;
#else
uniform lowp sampler2D supportBuffer;
#endif
uniform float radius;
#endif
in vec2 vUv;in vec2 vUv0,vUv1,vUv2,vUv3;in vec2 vUv4,vUv5,vUv6,vUv7;void main(){vec4 c=vec4(0.0);c+=texture(inputBuffer,vUv0)*0.0625;c+=texture(inputBuffer,vUv1)*0.125;c+=texture(inputBuffer,vUv2)*0.0625;c+=texture(inputBuffer,vUv3)*0.125;c+=texture(inputBuffer,vUv)*0.25;c+=texture(inputBuffer,vUv4)*0.125;c+=texture(inputBuffer,vUv5)*0.0625;c+=texture(inputBuffer,vUv6)*0.125;c+=texture(inputBuffer,vUv7)*0.0625;
#ifdef USE_SUPPORT_BUFFER
vec4 baseColor=texture(supportBuffer,vUv);out_Color=mix(baseColor,c,radius);
#else
out_Color=c;
#endif
}`,cs=`#include <pp_resolution_pars_fragment>
out vec2 vUv;out vec2 vUv0,vUv1,vUv2,vUv3;out vec2 vUv4,vUv5,vUv6,vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+resolution.zw*vec2(-1.0,1.0);vUv1=vUv+resolution.zw*vec2(0.0,1.0);vUv2=vUv+resolution.zw*vec2(1.0,1.0);vUv3=vUv+resolution.zw*vec2(-1.0,0.0);vUv4=vUv+resolution.zw*vec2(1.0,0.0);vUv5=vUv+resolution.zw*vec2(-1.0,-1.0);vUv6=vUv+resolution.zw*vec2(0.0,-1.0);vUv7=vUv+resolution.zw*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}`,hs=class extends F{constructor({radius:i=.85}={}){super({name:"UpsamplingMaterial",fragmentShader:ls,vertexShader:cs,defines:{USE_SUPPORT_BUFFER:!0},uniforms:{supportBuffer:new E(null),texelSize:new E(new I),radius:new E(0)}}),this.radius=i}set supportBuffer(i){this.uniforms.supportBuffer.value=i}get radius(){return this.uniforms.radius.value}set radius(i){this.uniforms.radius.value=i;const t=this.defines.USE_SUPPORT_BUFFER!==void 0,e=i<1;t!==e&&(e?this.defines.USE_SUPPORT_BUFFER=!0:delete this.defines.USE_SUPPORT_BUFFER,this.needsUpdate=!0)}},T,ds=(T=class extends v{constructor({levels:e=8,radius:s,fullResolutionUpsampling:r=!1,clampToBorder:n}={}){super("MipmapBlurPass");a(this,"downsamplingMipmaps");a(this,"upsamplingMipmaps");a(this,"downsamplingMaterial");a(this,"upsamplingMaterial");a(this,"_fullResolutionUpsampling");const o=this.createFramebuffer();o.texture.name=T.BUFFER_MAIN,this.output.setBuffer(T.BUFFER_MAIN,o),this.downsamplingMipmaps=[],this.upsamplingMipmaps=[],this.downsamplingMaterial=new fs({clampToBorder:n}),this.upsamplingMaterial=new hs({radius:s}),this.materials.add(this.downsamplingMaterial),this.materials.add(this.upsamplingMaterial),this._fullResolutionUpsampling=r,this.levels=e}get texture(){return this.output.buffers.get(T.BUFFER_MAIN).texture}get levels(){return this.downsamplingMipmaps.length}set levels(e){if(e<=0)throw new Error("The level count must be greater than 0");this.levels!==e&&this.createMipmaps(e)}get radius(){return this.upsamplingMaterial.radius}set radius(e){this.upsamplingMaterial.radius=e}get fullResolutionUpsampling(){return this._fullResolutionUpsampling}set fullResolutionUpsampling(e){this._fullResolutionUpsampling!==e&&(this._fullResolutionUpsampling=e,this.createMipmaps(this.levels))}createMipmaps(e){const s=this.output,r=s.buffers.get(T.BUFFER_MAIN),n=r.value;if(this.dispose(),this.disposables.clear(),s.buffers.clear(),this.downsamplingMipmaps=[],this.upsamplingMipmaps=[],e===1&&!this.fullResolutionUpsampling){s.setBuffer(T.BUFFER_MAIN,r),this.downsamplingMipmaps.push(r);return}for(let o=0;o<e;++o){const u=n.clone();u.texture.name="DOWNSAMPLING_MIPMAP"+o;const f=new J(u);s.setBuffer(u.texture.name,f),this.downsamplingMipmaps.push(f)}s.setBuffer(T.BUFFER_MAIN,r),this.upsamplingMipmaps.push(r);for(let o=1,u=this.fullResolutionUpsampling?e:e-1;o<u;++o){const f=n.clone();f.texture.name="UPSAMPLING_MIPMAP"+o;const l=new J(f);s.setBuffer(f.texture.name,l),this.upsamplingMipmaps.push(l)}this.onResolutionChange()}onInputChange(){var u;const e=((u=this.input.defaultBuffer)==null?void 0:u.value)??null;if(e===null)return;const{format:s,internalFormat:r,type:n,colorSpace:o}=e;for(const f of this.downsamplingMipmaps.concat(this.upsamplingMipmaps)){const l=f.value,c=l.texture;c.format=s,c.internalFormat=r,c.type=n,c.colorSpace=o,l.dispose()}this.input.frameBufferPrecisionHigh?(this.downsamplingMaterial.outputPrecision="mediump",this.upsamplingMaterial.outputPrecision="mediump"):(this.downsamplingMaterial.outputPrecision="lowp",this.upsamplingMaterial.outputPrecision="lowp"),this.onResolutionChange()}onResolutionChange(){var o,u,f;const e=((o=this.input.defaultBuffer)==null?void 0:o.value)??null;if(e===null)return;const s=e.source.data;let{width:r,height:n}=s;for(let l=0,c=this.downsamplingMipmaps.length;l<c;++l)r=Math.round(r/2),n=Math.round(n/2),(u=this.downsamplingMipmaps[l].value)==null||u.setSize(r,n);this.fullResolutionUpsampling?(r=s.width,n=s.height):(r=Math.round(s.width/2),n=Math.round(s.height/2));for(let l=0,c=this.upsamplingMipmaps.length;l<c;++l)(f=this.upsamplingMipmaps[l].value)==null||f.setSize(r,n),r=Math.round(r/2),n=Math.round(n/2)}render(){if(this.renderer===null||this.input.defaultBuffer===null||this.input.defaultBuffer.value===null)return;const e=this.renderer,s=this.downsamplingMaterial,r=this.upsamplingMaterial,n=this.downsamplingMipmaps,o=this.upsamplingMipmaps;let u=this.input.defaultBuffer.value;const f=u.source.data;let{width:l,height:c}=f;this.fullscreenMaterial=s;for(let h=0,p=n.length;h<p;++h){const m=n[h].value;s.setSize(l,c),s.inputBuffer=u,e.setRenderTarget(m),this.renderFullscreen(),u=m.texture,l=m.width,c=m.height}this.fullscreenMaterial=r;for(let h=o.length-1;h>=0;--h){const p=this.fullResolutionUpsampling?h-1:h,m=p>=0?n[p].value.texture:this.input.defaultBuffer.value,w=o[h].value;r.setSize(l,c),r.inputBuffer=u,r.supportBuffer=m,e.setRenderTarget(w),this.renderFullscreen(),u=w.texture,l=w.width,c=w.height}}},a(T,"BUFFER_MAIN","BUFFER_MAIN"),T),ve=class extends v{constructor(t){super(t);a(this,"blendMode");a(this,"_fragmentShader");a(this,"_vertexShader");a(this,"_inputColorSpace");a(this,"_outputColorSpace");a(this,"optional");this.blendMode=new Kt(new rs),this.blendMode.addEventListener(v.EVENT_CHANGE,()=>this.setChanged()),this._fragmentShader=null,this._vertexShader=null,this._inputColorSpace=H,this._outputColorSpace=H,this.optional=!1}get enabled(){return super.enabled}set enabled(t){super.enabled!==t&&(this.optional=!0),super.enabled=t}get fragmentShader(){return this._fragmentShader}set fragmentShader(t){this._fragmentShader=t,this.setChanged()}get vertexShader(){return this._vertexShader}set vertexShader(t){this._vertexShader=t,this.setChanged()}get inputColorSpace(){return this._inputColorSpace}set inputColorSpace(t){this._inputColorSpace=t,this.setChanged()}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(t){this._outputColorSpace=t,this.setChanged()}get hasMainImageFunction(){const t=/vec4\s+mainImage\s*\([a-z\s]*vec4\s+\w+,[a-z\s]*vec2\s+\w+,[a-z\s]*GData\s+\w+\)/;return this.fragmentShader!==null&&t.test(this.fragmentShader)}get hasMainUvFunction(){const t=/void\s+mainUv\s*\(\s*inout\s+vec2\s+\w+\)/;return this.fragmentShader!==null&&t.test(this.fragmentShader)}get hasMainSupportFunction(){const t=/void\s+mainSupport\s*\([a-z\s]*vec2\s+\w+\)/;return this.vertexShader!==null&&t.test(this.vertexShader)}validate(){if(this.fragmentShader===null)throw new Error(`Missing fragment shader (${this.name})`);if(!this.hasMainImageFunction&&!this.hasMainUvFunction)throw new Error(`Could not find a valid mainImage or mainUv function (${this.name})`)}render(){}},ps=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;vec4 mainImage(const in vec4 inputColor,const in vec2 uv,const in GData gData){vec3 texel=texture(map,uv).rgb;return vec4(texel*intensity,inputColor.a);}`,xs=class extends ve{constructor({luminanceThreshold:t=1,luminanceSmoothing:e=.03,intensity:s=1,radius:r=.85,levels:n=8,fullResolutionUpsampling:o,clampToBorder:u}={}){super("BloomEffect");a(this,"luminancePass");a(this,"mipmapBlurPass");this.fragmentShader=ps,this.blendMode.blendFunction=new ts;const f=new as;f.addEventListener(v.EVENT_TOGGLE,()=>this.onInputChange()),this.luminancePass=f;const l=this.luminanceMaterial;l.threshold=t,l.smoothing=e,l.colorOutput=!0;const c=new ds({levels:n,radius:r,fullResolutionUpsampling:o,clampToBorder:u});this.mipmapBlurPass=c;const h=this.input.uniforms;h.set("intensity",new E(s)),h.set("map",new E(null)),c.texture.bindUniform(h.get("map")),this.subpasses=[f,c]}get luminanceMaterial(){return this.luminancePass.fullscreenMaterial}get intensity(){return this.input.uniforms.get("intensity").value}set intensity(t){this.input.uniforms.get("intensity").value=t}onResolutionChange(){const t=this.resolution;this.luminancePass.resolution.copy(t),this.mipmapBlurPass.resolution.copy(t)}onInputChange(){this.luminancePass.enabled?(this.luminancePass.input.defaultBuffer=this.input.defaultBuffer,this.mipmapBlurPass.input.defaultBuffer=this.luminancePass.texture):this.mipmapBlurPass.input.defaultBuffer=this.input.defaultBuffer}render(){this.luminancePass.enabled&&this.luminancePass.render(),this.mipmapBlurPass.render()}},gs=`#include <tonemapping_pars_fragment>
vec4 mainImage(const in vec4 inputColor,const in vec2 uv,const in GData gData){return vec4(toneMapping(inputColor.rgb),inputColor.a);}`,ms=new Map([[0,"LinearToneMapping(texel)"],[1,"ReinhardToneMapping(texel)"],[2,"CineonToneMapping(texel)"],[3,"ACESFilmicToneMapping(texel)"],[4,"AgXToneMapping(texel)"],[5,"NeutralToneMapping(texel)"],[6,"CustomToneMapping(texel)"]]),ws=class extends ve{constructor({toneMapping:i=4}={}){super("ToneMappingEffect"),this.fragmentShader=gs,this.toneMapping=i}get toneMapping(){return this.input.defines.get("TONE_MAPPING")}set toneMapping(i){if(this.toneMapping!==i){const t=this.input.defines;t.clear(),t.set("TONE_MAPPING",i);const e=ms.get(i);if(e===void 0)throw new Error(`Invalid tone mapping: ${i}`);t.set("toneMapping(texel)",e),this.setChanged()}}},vs=`#include <common>
#include <dithering_pars_fragment>
#include <packing>
#include <pp_camera_pars_fragment>
#include <pp_colorspace_conversion_pars_fragment>
#include <pp_default_output_pars_fragment>
#include <pp_depth_buffer_precision_pars_fragment>
#include <pp_depth_utils_pars_fragment>
#include <pp_frame_buffer_precision_pars_fragment>
#include <pp_resolution_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
$FRAGMENT_HEAD_GDATA$FRAGMENT_HEAD_GBUFFER uniform GBuffer gBuffer;uniform float time;in vec2 vUv;$FRAGMENT_HEAD_EFFECTS void main(){$FRAGMENT_MAIN_UV$FRAGMENT_MAIN_GDATA vec4 color0=gData.color;vec4 color1=vec4(0.0);$FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);out_Color=color0;
#ifdef COLOR_SPACE_CONVERSION
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
}`,Es=`#include <pp_resolution_pars_fragment>
uniform vec3 cameraParams;uniform float time;out vec2 vUv;$VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;$VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}`,Te=class extends F{constructor(){super({name:"EffectMaterial",defines:{COLOR_SPACE_CONVERSION:!0},uniforms:{gBuffer:new E(null),time:new E(0)}});a(this,"customUniforms");a(this,"customDefines");this.customUniforms=new Map,this.customDefines=new Map,this.fragmentShader=`#include <pp_default_output_pars_fragment>

`+this.fragmentShader}get gBuffer(){return this.uniforms.gBuffer.value}set gBuffer(t){this.uniforms.gBuffer.value=t}get colorSpaceConversion(){return this.defines.COLOR_SPACE_CONVERSION!==void 0}set colorSpaceConversion(t){this.colorSpaceConversion!==t&&(t?this.defines.COLOR_SPACE_CONVERSION=!0:delete this.defines.COLOR_SPACE_CONVERSION,this.needsUpdate=!0)}get time(){return this.uniforms.time.value}set time(t){this.uniforms.time.value=t}setShaderParts(t){return this.fragmentShader=vs.replace("$FRAGMENT_MAIN_IMAGE",t.get("$FRAGMENT_MAIN_IMAGE")).replace("$FRAGMENT_MAIN_GDATA",t.get("$FRAGMENT_MAIN_GDATA")).replace("$FRAGMENT_MAIN_UV",t.get("$FRAGMENT_MAIN_UV")).replace("$FRAGMENT_HEAD_EFFECTS",t.get("$FRAGMENT_HEAD_EFFECTS")).replace("$FRAGMENT_HEAD_GBUFFER",t.get("$FRAGMENT_HEAD_GBUFFER")).replace("$FRAGMENT_HEAD_GDATA",t.get("$FRAGMENT_HEAD_GDATA")),this.vertexShader=Es.replace("$VERTEX_MAIN_SUPPORT",t.get("$VERTEX_MAIN_SUPPORT")).replace("$VERTEX_HEAD",t.get("$VERTEX_HEAD")),this.needsUpdate=!0,this}setDefines(t){for(const e of this.customDefines.keys())delete this.defines[e];this.customDefines.clear();for(const e of t.entries())this.defines[e[0]]=e[1],this.customDefines.set(e[0],e[1]);return this.needsUpdate=!0,this}setUniforms(t){for(const e of this.customUniforms.keys())delete this.uniforms[e];this.customUniforms.clear();for(const e of t.entries())this.uniforms[e[0]]=e[1],this.customUniforms.set(e[0],e[1]);return this.uniformsNeedUpdate=!0,this}};function be(i,t,e){for(const s of t){const r="$1"+i+s.charAt(0).toUpperCase()+s.slice(1),n=new RegExp("([^\\.])(\\b"+s+"\\b)","g");for(const o of e.entries())typeof o[1]=="string"&&e.set(o[0],o[1].replace(n,r))}}var Ae=/\w+\s+(\w+)\([\w\s,]*\)\s*{/g,xe=/struct\s+(\w*)/g,we=/^\s*#define\s+(\w*)/gm,Ne=class{constructor(i=null){a(this,"defines");a(this,"uniforms");a(this,"shaderParts");a(this,"blendModes");a(this,"gData");a(this,"convolutionEffects");a(this,"_uvTransformation");a(this,"_colorSpace");a(this,"gBufferConfig");this.gBufferConfig=i??new Q,this.shaderParts=new Map([["$FRAGMENT_HEAD_EFFECTS",""],["$FRAGMENT_HEAD_GBUFFER",""],["$FRAGMENT_HEAD_GDATA",""],["$FRAGMENT_MAIN_UV",""],["$FRAGMENT_MAIN_GDATA",""],["$FRAGMENT_MAIN_IMAGE",""],["$VERTEX_HEAD",""],["$VERTEX_MAIN_SUPPORT",""]]),this.defines=new Map,this.uniforms=new Map,this.blendModes=new Map,this.gData=new Set(["color"]),this.convolutionEffects=new Set,this._uvTransformation=!1,this._colorSpace=Ct}get uvTransformation(){return this._uvTransformation}set uvTransformation(i){this._uvTransformation=i}get colorSpace(){return this._colorSpace}set colorSpace(i){this._colorSpace=i}gatherVertexShaderTokens(i,t){for(const e of i.matchAll(/(?:out\s+\w+\s+(\w*?);)/g))for(const s of e[1].split(/\s*,\s*/))t.add(s);for(const e of i.matchAll(Ae))t.add(e[1]);for(const e of i.matchAll(xe))t.add(e[1]);for(const e of i.matchAll(we))t.add(e[1])}gatherFragmentShaderTokens(i,t){for(const e of i.matchAll(Ae))t.add(e[1]);for(const e of i.matchAll(xe))t.add(e[1]);for(const e of i.matchAll(we))t.add(e[1])}detectGDataUsage(i){const t=/GData\s+(\w+)/.exec(i)[1];for(const e of Object.values(De))if(new RegExp(`${t}.${e}`).test(i)){for(const r of this.gBufferConfig.gDataDependencies.get(e)??[])this.gData.add(r);this.gData.add(e)}}updateWorkingColorSpace(i){i.outputColorSpace!==H?this.colorSpace=i.outputColorSpace:i.inputColorSpace!==H&&(this.colorSpace=i.inputColorSpace)}integrateEffect(i,t){t.validate(),t.isConvolutionPass(!1)&&this.convolutionEffects.add(t);let e=t.fragmentShader,s=t.vertexShader;const r=this.shaderParts;let n=r.get("$FRAGMENT_HEAD_EFFECTS"),o=r.get("$FRAGMENT_MAIN_UV"),u=r.get("$FRAGMENT_MAIN_IMAGE"),f=r.get("$VERTEX_HEAD"),l=r.get("$VERTEX_MAIN_SUPPORT");const c=new Set;if(s!==null&&t.hasMainSupportFunction){this.gatherVertexShaderTokens(s,c);const p=/mainSupport\s*\([\w\s]*?uv\s*?\)/.test(s);l+=`	${i}MainSupport(`,l+=p?`vUv);
`:`);
`}if(t.hasMainUvFunction&&(o+=`	${i}MainUv(UV);
`,this.uvTransformation=!0),t.hasMainImageFunction){this.detectGDataUsage(e),this.gatherFragmentShaderTokens(e,c),t.inputColorSpace!==H&&t.inputColorSpace!==this.colorSpace&&(u+=t.inputColorSpace===Z?`color0 = sRGBTransferOETF(color0);
	`:`color0 = sRGBToLinear(color0);
	`),u+=`color1 = ${i}MainImage(color0, UV, gData);
	`;const p=t.blendMode;this.blendModes.set(p.blendFunction.id,p);const m=i+"BlendOpacity";this.uniforms.set(m,p.opacityUniform),u+=`color0 = blend${p.blendFunction.id}(color0, color1, ${m});

	`,n+=`uniform float ${m};

`,this.updateWorkingColorSpace(t)}for(const p of t.input.defines.keys())c.add(p.replace(/\([\w\s,]*\)/g,""));for(const p of t.input.uniforms.keys())c.add(p);c.delete("while"),c.delete("for"),c.delete("if"),t.input.uniforms.forEach((p,m)=>this.uniforms.set(i+m.charAt(0).toUpperCase()+m.slice(1),p)),t.input.defines.forEach((p,m)=>this.defines.set(i+m.charAt(0).toUpperCase()+m.slice(1),p));const h=new Map([["fragment",e],["vertex",s]]);be(i,c,this.defines),be(i,c,h),e=h.get("fragment"),s=h.get("vertex"),n+=e+`
`,s!==null&&(f+=s+`
`),r.set("$FRAGMENT_HEAD_EFFECTS",n),r.set("$FRAGMENT_MAIN_UV",o),r.set("$FRAGMENT_MAIN_IMAGE",u),r.set("$VERTEX_HEAD",f),r.set("$VERTEX_MAIN_SUPPORT",l),this.validate()}add(i){this.uvTransformation||(this.uvTransformation=i.uvTransformation),i.convolutionEffects.forEach(u=>this.convolutionEffects.add(u)),i.uniforms.forEach((u,f)=>this.uniforms.set(f,u)),i.defines.forEach((u,f)=>this.defines.set(f,u)),i.blendModes.forEach((u,f)=>this.blendModes.set(f,u)),i.gData.forEach(u=>this.gData.add(u));const t=this.shaderParts;let e=t.get("$FRAGMENT_HEAD_EFFECTS"),s=t.get("$FRAGMENT_MAIN_UV"),r=t.get("$FRAGMENT_MAIN_IMAGE"),n=t.get("$VERTEX_HEAD"),o=t.get("$VERTEX_MAIN_SUPPORT");e+=i.shaderParts.get("$FRAGMENT_HEAD_EFFECTS"),s+=i.shaderParts.get("$FRAGMENT_MAIN_UV"),r+=i.shaderParts.get("$FRAGMENT_MAIN_IMAGE"),n+=i.shaderParts.get("$VERTEX_HEAD"),o+=i.shaderParts.get("$VERTEX_MAIN_SUPPORT"),t.set("$FRAGMENT_HEAD_EFFECTS",e),t.set("$FRAGMENT_MAIN_UV",s),t.set("$FRAGMENT_MAIN_IMAGE",r),t.set("$VERTEX_HEAD",n),t.set("$VERTEX_MAIN_SUPPORT",o),this.colorSpace!==i.colorSpace&&i.colorSpace!==H&&(this.colorSpace=i.colorSpace),this.validate()}validate(){if(this.convolutionEffects.size>1){const i=Array.from(this.convolutionEffects).map(t=>t.name).join(", ");throw new Error(`Convolution effects cannot be merged (${i})`)}else if(this.convolutionEffects.size>0&&this.uvTransformation)throw new Error("Effects that transform UVs are incompatible with convolution effects")}createGBufferStruct(){return["struct GBuffer {",...Array.from(this.gBufferConfig.gBufferStructDeclaration).filter(i=>this.gData.has(i[0])).map(i=>`	${i[1]}`),`};
`].join(`
`)}createGDataStructDeclaration(){return["struct GData {",...Array.from(this.gBufferConfig.gDataStructDeclaration).filter(i=>this.gData.has(i[0])).map(i=>`	${i[1]}`),`};
`].join(`
`)}createGDataStructInitialization(){const i=this.gBufferConfig.gDataDependencies;return["	GData gData;",...Array.from(this.gBufferConfig.gDataStructInitialization).filter(t=>this.gData.has(t[0])).sort((t,e)=>i.has(t[0])&&i.get(t[0]).has(e[0])?1:-1).map(t=>`	${t[1]}`)].join(`
`)}createBlendFunctions(){const i=/\bblend\b/g,t=[];for(const e of this.blendModes.values()){const s=e.blendFunction.shader,r=`blend${e.blendFunction.id}`;t.push(s.replace(i,r))}return t.join(`
`)}},B,_s=(B=class{constructor(t){a(this,"shaderData");a(this,"defaultMaterial");a(this,"materialCache");a(this,"effectShaderDataCache");a(this,"effectChangeListener");a(this,"activeMaterial");a(this,"_effects");a(this,"_gBufferConfig");a(this,"_dithering");a(this,"_gBuffer");this.shaderData=t,this.defaultMaterial=new Te,this.materialCache=new Map,this.effectShaderDataCache=new Map,this.effectChangeListener=e=>this.effectShaderDataCache.delete(e.target),this.activeMaterial=null,this._effects=[],this._gBufferConfig=null,this._dithering=!1,this._gBuffer=null}get materials(){return this.materialCache.values()}get effects(){return this._effects}set effects(t){this.dispose(),this._effects=t;for(const e of this._effects)e.addEventListener(v.EVENT_CHANGE,this.effectChangeListener)}get gBufferConfig(){return this._gBufferConfig}set gBufferConfig(t){this._gBufferConfig!==t&&(this.dispose(),this._gBufferConfig=t)}get dithering(){return this._dithering}set dithering(t){if(this._dithering!==t){this._dithering=t;for(const e of this.materialCache.values())if(t&&e.outputPrecision!=="lowp"){console.info("Dithering only works on 8-bit colors");break}else e.dithering=t,e.needsUpdate=!0}}getEffectShaderData(t){const e=new Ne(this.gBufferConfig),s=this.effectShaderDataCache;for(const r of t){if(!s.has(r)){const n=new Ne(this.gBufferConfig);n.integrateEffect(`e${r.id}`,r),s.set(r,n)}r.blendMode.blendFunction.shader!==null&&e.add(s.get(r))}return e}createMaterial(t){const s=B.getMaterialId(t)===B.DEFAULT_MATERIAL_ID?this.defaultMaterial:new Te,r=this.getEffectShaderData(t);r.shaderParts.set("$FRAGMENT_HEAD_GBUFFER",r.createGBufferStruct()),r.shaderParts.set("$FRAGMENT_HEAD_GDATA",r.createGDataStructDeclaration()),r.shaderParts.set("$FRAGMENT_MAIN_GDATA",r.createGDataStructInitialization());const n=r.shaderParts.get("$FRAGMENT_HEAD_EFFECTS");if(r.shaderParts.set("$FRAGMENT_HEAD_EFFECTS",n+r.createBlendFunctions()),r.colorSpace===Z){const o=r.shaderParts.get("$FRAGMENT_MAIN_IMAGE");r.shaderParts.set("$FRAGMENT_MAIN_IMAGE",o+`color0 = sRGBToLinear(color0);
	`)}if(r.uvTransformation){const o=r.shaderParts.get("$FRAGMENT_MAIN_UV");r.shaderParts.set("$FRAGMENT_MAIN_UV",`vec2 transformedUv = vUv;
`+o),r.defines.set("UV","transformedUv")}else r.defines.set("UV","vUv");r.shaderParts.forEach((o,u,f)=>f.set(u,o.trim().replace(/^#/,`
#`)));for(const o of this.shaderData.defines)r.defines.set(o[0],o[1]);for(const o of this.shaderData.uniforms)r.uniforms.set(o[0],o[1]);if(s!==this.defaultMaterial){for(const o of Object.entries(this.defaultMaterial.uniforms))s.uniforms[o[0]]=o[1];for(const o of Object.entries(this.defaultMaterial.defines))s.defines[o[0]]=o[1]}return s.setShaderParts(r.shaderParts).setDefines(r.defines).setUniforms(r.uniforms)}createMaterials(){const t=this.effects,e=t.filter(r=>r.optional),s=e.length>B.MAX_OPTIONAL_EFFECTS;if(e.length===0||s){const r=t.filter(o=>o.enabled),n=B.getMaterialId(r);this.materialCache.set(n,this.createMaterial(r))}else for(const r of this.getEffectCombinations()){const n=B.getMaterialId(r);this.materialCache.has(n)||this.materialCache.set(n,this.createMaterial(r))}}synchronizeMaterials(){if(this.activeMaterial===null)return;const t=this.activeMaterial,e=this.defaultMaterial;for(const s of Object.entries(e.defines))s[1]!==t.defines[s[0]]&&(e.defines[s[0]]=t.defines[s[0]],e.needsUpdate=!0);if(e.needsUpdate){for(const s of this.materialCache.values())if(s!==e){for(const r of Object.entries(e.defines))s.defines[r[0]]=r[1];s.needsUpdate=!0}}}getMaterial(){if(this.gBufferConfig===null)return this.defaultMaterial;this.synchronizeMaterials();const t=this.effects.filter(s=>s.enabled),e=B.getMaterialId(t);return this.materialCache.has(e)||this.createMaterials(),this.activeMaterial=this.materialCache.get(e),this.activeMaterial}*getEffectCombinations(){const t=this.effects,e=t.filter(n=>n.optional),s=e.length,r=1<<s;for(let n=0;n<r;++n){const o=[];for(let u=0;u<s;++u)n&1<<u&&o.push(e[u]);yield t.filter(u=>!u.optional||o.includes(u))}}invalidateMaterialCache(){for(const t of this.materialCache.values())t.dispose();this.materialCache.clear()}dispose(){for(const t of this._effects)t.removeEventListener(v.EVENT_CHANGE,this.effectChangeListener);this.invalidateMaterialCache(),this.effectShaderDataCache.clear(),this.activeMaterial=null}static getMaterialId(t){return t.length===0?B.DEFAULT_MATERIAL_ID:t.map(e=>e.id).join("-")}},a(B,"MAX_OPTIONAL_EFFECTS",6),a(B,"DEFAULT_MATERIAL_ID","default"),B),Ns=class extends v{constructor(...t){super("EffectPass");a(this,"effectMaterialManager");a(this,"effectChangeListener");a(this,"effectToggleListener");a(this,"previousGBufferConfig");a(this,"timeScale");this.output.defaultBuffer=this.createFramebuffer(),this.effectMaterialManager=new _s(this.input),this.effectChangeListener=()=>this.updateMaterial(!0),this.effectToggleListener=()=>this.updateMaterial(!1),this.previousGBufferConfig=null,this.effects=t,this.timeScale=1}get subpasses(){return super.subpasses}set subpasses(t){for(const e of super.subpasses)e.removeEventListener(v.EVENT_CHANGE,this.effectChangeListener),e.removeEventListener(v.EVENT_TOGGLE,this.effectToggleListener);super.subpasses=t,this.input.gBuffer.clear();for(const e of super.subpasses){for(const s of e.input.gBuffer)this.input.gBuffer.add(s);e.addEventListener(v.EVENT_CHANGE,this.effectChangeListener),e.addEventListener(v.EVENT_TOGGLE,this.effectToggleListener)}this.updateMaterial(!0)}get effects(){return this.subpasses}set effects(t){const e=new Set(t);if(e.size<t.length){const s=t.filter(r=>!e.has(r)).map(r=>r.name);throw new Error(`Encountered duplicate effects: ${s.join(", ")}`)}this.effectMaterialManager.effects=t,this.subpasses=t}get dithering(){return this.effectMaterialManager.dithering}set dithering(t){this.effectMaterialManager.dithering=t}updateMaterial(t){try{t&&(this.effectMaterialManager.invalidateMaterialCache(),this.materials.clear()),this.fullscreenMaterial=this.effectMaterialManager.getMaterial();for(const e of this.effectMaterialManager.materials)this.materials.add(e)}catch(e){console.error(e),console.info("Disabling pass:",this),this.enabled=!1}}updateGBufferStruct(){var r,n;const t=this.input,e=t.gBufferConfig;if(e===null)return;const s=[];for(const o of t.gBuffer){const f=o==="Color"?(r=t.defaultBuffer)==null?void 0:r.value:(n=t.buffers.get(o))==null?void 0:n.value;s.push([e.gBufferStructFields.get(o),f??null])}this.fullscreenMaterial.gBuffer=Object.fromEntries(s)}onInputChange(){this.updateGBufferStruct();for(const t of this.effects){t.input.buffers.clear();for(const e of this.input.buffers)t.input.buffers.set(e[0],e[1])}this.previousGBufferConfig!==this.input.gBufferConfig&&(this.previousGBufferConfig!==null&&this.previousGBufferConfig.removeEventListener(Q.EVENT_CHANGE,this.effectChangeListener),this.input.gBufferConfig!==null&&this.input.gBufferConfig.addEventListener(Q.EVENT_CHANGE,this.effectChangeListener),this.previousGBufferConfig=this.input.gBufferConfig,this.effectMaterialManager.gBufferConfig=this.input.gBufferConfig,this.updateMaterial(!0))}onResolutionChange(){const t=this.resolution;this.fullscreenMaterial.setSize(t.width,t.height);for(const e of this.effects)e.resolution.setBaseSize(t.baseWidth,t.baseHeight)}checkRequirements(t){for(const e of this.effects)e.checkRequirements(t)}async compile(){return this.updateMaterial(!1),super.compile()}dispose(){for(const t of this.effects)t.removeEventListener(v.EVENT_CHANGE,this.effectChangeListener),t.removeEventListener(v.EVENT_TOGGLE,this.effectToggleListener);this.effectMaterialManager.dispose(),super.dispose()}render(){var t;if(!(this.renderer===null||this.timer===null)){for(const e of this.effects)e.enabled&&e.render();this.fullscreenMaterial.time+=this.timer.getDelta()*this.timeScale,this.setRenderTarget((t=this.output.defaultBuffer)==null?void 0:t.value),this.renderFullscreen()}}};new pe;var Bs={};St(Bs,{analyzePipeline:()=>Ss});function N(i,t){if(t===null||t.value===null)return"canvas";const e=t instanceof J?t.value.texture.uuid:t.value.uuid;return e!==null?i.get(e)??"unknown":"canvas"}function He(i,t=new Map,e=0){for(const s of i){for(const r of s.input.buffers.values())r.value!==null&&!t.has(r.value.uuid)&&t.set(r.value.uuid,e++);for(const r of s.output.buffers.values())r.value!==null&&!t.has(r.value.texture.uuid)&&t.set(r.value.texture.uuid,e++);He(s.subpasses,t,e)}return t}function Ve(i,t){for(const e of i){console.group(`${e.name} p${e.id}`);const{input:s,output:r}=e;if(!e.enabled)console.debug("disabled");else if(e instanceof ae)console.debug("clears",N(t,r.defaultBuffer));else{if(s.buffers.size>0){const n=Array.from(s.buffers.values()).filter(o=>{var u;return o.id!==((u=s.defaultBuffer)==null?void 0:u.id)});if(s.hasDefaultBuffer){const o=N(t,s.defaultBuffer);console.debug("reads",o,n.map(u=>N(t,u)).join(" "))}else console.debug("reads",n.map(o=>N(t,o)).join(" "))}if(r.buffers.size>0){const n=Array.from(r.buffers.values()).filter(o=>{var u;return o.id!==((u=r.defaultBuffer)==null?void 0:u.id)});if(r.hasDefaultBuffer){const o=N(t,r.defaultBuffer);console.debug("writes",o,n.map(u=>N(t,u)).join(" "))}else console.debug("writes",n.map(o=>N(t,o)).join(" "))}}Ve(e.subpasses,t),console.groupEnd()}}function ze(i,t=new Set){for(const e of i){for(const s of e.input.buffers.values())t.add(s);ze(e.subpasses,t)}return t}function $e(i,t=new Set){for(const e of i){for(const s of e.output.buffers.values())t.add(s);$e(e.subpasses,t)}return t}function Cs(i,t){var s;const e=ze(i);for(const r of e)console.debug(`${N(t,r)}:`,`(${r.id})`,(s=r.value)==null?void 0:s.uuid)}function Rs(i,t){var s;const e=$e(i);for(const r of e)console.debug(`${N(t,r)}:`,`(${r.id} â ${r.texture.id})`,((s=r.texture.value)==null?void 0:s.uuid)??"null")}function Ss(i){const t=He(i.passes);console.debug("RenderPipeline",i),console.groupCollapsed("Data Flow"),Ve(i.passes,t),console.groupEnd(),console.groupCollapsed("Resources"),console.group("Input Buffers"),Cs(i.passes,t),console.groupEnd(),console.group("Output Buffers"),Rs(i.passes,t),console.groupEnd(),console.groupEnd()}var ke=(i=>(i[i.NOISECOLOR=0]="NOISECOLOR",i[i.ORDERED=1]="ORDERED",i[i.LUMABASED=2]="LUMABASED",i))(ke||{});const Ms=`#define NOISECOLOR 0
#define ORDERED 1
#define LUMABASED 2

uniform float intensity;

float rand(vec2 co) {
  return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

#if DITHERING_TYPE == ORDERED
// Bayer matrix for ordered dithering.
const mat4 bayerMatrix = mat4(
    0.0/16.0,  8.0/16.0,  2.0/16.0, 10.0/16.0,
   12.0/16.0,  4.0/16.0, 14.0/16.0,  6.0/16.0,
    3.0/16.0, 11.0/16.0,  1.0/16.0,  9.0/16.0,
   15.0/16.0,  7.0/16.0, 13.0/16.0,  5.0/16.0
);

vec3 orderedDithering(vec3 color, vec2 fragCoord) {
  ivec2 pixelCoord = ivec2(fragCoord);
  float bayerValue = bayerMatrix[pixelCoord.x % 4][pixelCoord.y % 4];
  return color + (bayerValue - 0.5) * intensity * 0.01;
}
#endif

#if DITHERING_TYPE == NOISECOLOR
vec3 noiseDitheringColor(vec3 color, vec2 fragCoord) {
  float grid_position = rand(fragCoord);
  vec3 dither_shift_RGB = vec3(0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0);
  dither_shift_RGB = mix(2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position);
  return color + dither_shift_RGB * intensity;
}
#endif

#if DITHERING_TYPE == LUMABASED
vec3 lumaNoiseDithering(vec3 color, vec2 fragCoord) {
  float luma = dot(color, vec3(0.2126, 0.7152, 0.0722));
  float noise = rand(fragCoord) - 0.5;
  float ditheredLuma = luma + noise * intensity * 0.0015;
  return color * (ditheredLuma / luma);
}
#endif

vec3 doDither(vec3 color, vec2 fragCoord) {
    #if DITHERING_TYPE == NOISECOLOR
        return noiseDitheringColor(color, fragCoord);
    #elif DITHERING_TYPE == ORDERED
        return orderedDithering(color, fragCoord);
    #elif DITHERING_TYPE == LUMABASED
        return lumaNoiseDithering(color, fragCoord);
    #else
        return color;
    #endif
}

vec4 mainImage(const in vec4 inputColor, const in vec2 uv, const in GData gData) {
  vec2 fragCoord = uv * resolution.xy;
  return vec4(doDither(inputColor.rgb, fragCoord), inputColor.a);
}`;class Us extends ve{constructor({intensity:t=1,ditheringType:e=ke.LUMABASED}={}){super("DitheringEffect"),this.fragmentShader=Ms,this.ditheringType=e,this.input.uniforms.set("intensity",new E(t))}get ditheringType(){return this.input.defines.get("DITHERING_TYPE")}set ditheringType(t){this.ditheringType!==t&&(this.input.defines.set("DITHERING_TYPE",t),this.setChanged())}get intensity(){return this.input.uniforms.get("intensity").value}set intensity(t){this.input.uniforms.get("intensity").value=t}}export{xs as B,ae as C,Us as D,Ns as E,ie as G,As as R,ws as T,Jt as a};
