import{C as y,L as v,S as j,O as J,H as L,F as R,M as G,P as N,W as k,R as A,U as O,a as Y,D as Q,b as U,c as W,T as F,d as K,I as Z,e as q,B as ee,f as te,g as B,h as re,i as ae,j as ie,k as H,l as ne,N as se,V as T}from"./vendor-three-B7e9swDm.js";const $=(h,e,t)=>{let a;switch(h){case B:a=new Uint8ClampedArray(e*t*4);break;case L:a=new Uint16Array(e*t*4);break;case te:a=new Uint32Array(e*t*4);break;case ee:a=new Int8Array(e*t*4);break;case q:a=new Int16Array(e*t*4);break;case Z:a=new Int32Array(e*t*4);break;case R:a=new Float32Array(e*t*4);break;default:throw new Error("Unsupported data type")}return a};let b;const oe=(h,e,t,a)=>{if(b!==void 0)return b;const i=new k(1,1,a);e.setRenderTarget(i);const r=new G(new N,new K({color:16777215}));e.render(r,t),e.setRenderTarget(null);const o=$(h,i.width,i.height);return e.readRenderTargetPixels(i,0,0,i.width,i.height,o),i.dispose(),r.geometry.dispose(),r.material.dispose(),b=o[0]!==0,b};class P{constructor(e){var t,a,i,r,o,s,l,d,c,f,n,u,g,x,w,_;this._rendererIsDisposable=!1,this._supportsReadPixels=!0,this.render=()=>{this._renderer.setRenderTarget(this._renderTarget);try{this._renderer.render(this._scene,this._camera)}catch(M){throw this._renderer.setRenderTarget(null),M}this._renderer.setRenderTarget(null)},this._width=e.width,this._height=e.height,this._type=e.type,this._colorSpace=e.colorSpace;const S={format:A,depthBuffer:!1,stencilBuffer:!1,type:this._type,colorSpace:this._colorSpace,anisotropy:((t=e.renderTargetOptions)===null||t===void 0?void 0:t.anisotropy)!==void 0?(a=e.renderTargetOptions)===null||a===void 0?void 0:a.anisotropy:1,generateMipmaps:((i=e.renderTargetOptions)===null||i===void 0?void 0:i.generateMipmaps)!==void 0?(r=e.renderTargetOptions)===null||r===void 0?void 0:r.generateMipmaps:!1,magFilter:((o=e.renderTargetOptions)===null||o===void 0?void 0:o.magFilter)!==void 0?(s=e.renderTargetOptions)===null||s===void 0?void 0:s.magFilter:v,minFilter:((l=e.renderTargetOptions)===null||l===void 0?void 0:l.minFilter)!==void 0?(d=e.renderTargetOptions)===null||d===void 0?void 0:d.minFilter:v,samples:((c=e.renderTargetOptions)===null||c===void 0?void 0:c.samples)!==void 0?(f=e.renderTargetOptions)===null||f===void 0?void 0:f.samples:void 0,wrapS:((n=e.renderTargetOptions)===null||n===void 0?void 0:n.wrapS)!==void 0?(u=e.renderTargetOptions)===null||u===void 0?void 0:u.wrapS:y,wrapT:((g=e.renderTargetOptions)===null||g===void 0?void 0:g.wrapT)!==void 0?(x=e.renderTargetOptions)===null||x===void 0?void 0:x.wrapT:y};if(this._material=e.material,e.renderer?this._renderer=e.renderer:(this._renderer=P.instantiateRenderer(),this._rendererIsDisposable=!0),this._scene=new j,this._camera=new J,this._camera.position.set(0,0,10),this._camera.left=-.5,this._camera.right=.5,this._camera.top=.5,this._camera.bottom=-.5,this._camera.updateProjectionMatrix(),!oe(this._type,this._renderer,this._camera,S)){let M;switch(this._type){case L:M=this._renderer.extensions.has("EXT_color_buffer_float")?R:void 0;break}M!==void 0?(console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${R}`),this._type=M):(this._supportsReadPixels=!1,console.warn("This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown"))}this._quad=new G(new N,this._material),this._quad.geometry.computeBoundingBox(),this._scene.add(this._quad),this._renderTarget=new k(this.width,this.height,S),this._renderTarget.texture.mapping=((w=e.renderTargetOptions)===null||w===void 0?void 0:w.mapping)!==void 0?(_=e.renderTargetOptions)===null||_===void 0?void 0:_.mapping:O}static instantiateRenderer(){const e=new Y;return e.setSize(128,128),e}toArray(){if(!this._supportsReadPixels)throw new Error("Can't read pixels in this browser");const e=$(this._type,this._width,this._height);return this._renderer.readRenderTargetPixels(this._renderTarget,0,0,this._width,this._height,e),e}toDataTexture(e){const t=new Q(this.toArray(),this.width,this.height,A,this._type,(e==null?void 0:e.mapping)||O,(e==null?void 0:e.wrapS)||y,(e==null?void 0:e.wrapT)||y,(e==null?void 0:e.magFilter)||v,(e==null?void 0:e.minFilter)||v,(e==null?void 0:e.anisotropy)||1,U);return t.generateMipmaps=(e==null?void 0:e.generateMipmaps)!==void 0?e==null?void 0:e.generateMipmaps:!1,t}disposeOnDemandRenderer(){this._renderer.setRenderTarget(null),this._rendererIsDisposable&&(this._renderer.dispose(),this._renderer.forceContextLoss())}dispose(e){this.disposeOnDemandRenderer(),e&&this.renderTarget.dispose(),this.material instanceof W&&Object.values(this.material.uniforms).forEach(t=>{t.value instanceof F&&t.value.dispose()}),Object.values(this.material).forEach(t=>{t instanceof F&&t.dispose()}),this.material.dispose(),this._quad.geometry.dispose()}get width(){return this._width}set width(e){this._width=e,this._renderTarget.setSize(this._width,this._height)}get height(){return this._height}set height(e){this._height=e,this._renderTarget.setSize(this._width,this._height)}get renderer(){return this._renderer}get renderTarget(){return this._renderTarget}set renderTarget(e){this._renderTarget=e,this._width=e.width,this._height=e.height}get material(){return this._material}get type(){return this._type}get colorSpace(){return this._colorSpace}}const de=`
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,le=`
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`;class he extends W{constructor({gamma:e,offsetHdr:t,offsetSdr:a,gainMapMin:i,gainMapMax:r,maxDisplayBoost:o,hdrCapacityMin:s,hdrCapacityMax:l,sdr:d,gainMap:c}){super({name:"GainMapDecoderMaterial",vertexShader:de,fragmentShader:le,uniforms:{sdr:{value:d},gainMap:{value:c},gamma:{value:new T(1/e[0],1/e[1],1/e[2])},offsetHdr:{value:new T().fromArray(t)},offsetSdr:{value:new T().fromArray(a)},gainMapMin:{value:new T().fromArray(i)},gainMapMax:{value:new T().fromArray(r)},weightFactor:{value:(Math.log2(o)-s)/(l-s)}},blending:se,depthTest:!1,depthWrite:!1}),this._maxDisplayBoost=o,this._hdrCapacityMin=s,this._hdrCapacityMax=l,this.needsUpdate=!0,this.uniformsNeedUpdate=!0}get sdr(){return this.uniforms.sdr.value}set sdr(e){this.uniforms.sdr.value=e}get gainMap(){return this.uniforms.gainMap.value}set gainMap(e){this.uniforms.gainMap.value=e}get offsetHdr(){return this.uniforms.offsetHdr.value.toArray()}set offsetHdr(e){this.uniforms.offsetHdr.value.fromArray(e)}get offsetSdr(){return this.uniforms.offsetSdr.value.toArray()}set offsetSdr(e){this.uniforms.offsetSdr.value.fromArray(e)}get gainMapMin(){return this.uniforms.gainMapMin.value.toArray()}set gainMapMin(e){this.uniforms.gainMapMin.value.fromArray(e)}get gainMapMax(){return this.uniforms.gainMapMax.value.toArray()}set gainMapMax(e){this.uniforms.gainMapMax.value.fromArray(e)}get gamma(){const e=this.uniforms.gamma.value;return[1/e.x,1/e.y,1/e.z]}set gamma(e){const t=this.uniforms.gamma.value;t.x=1/e[0],t.y=1/e[1],t.z=1/e[2]}get hdrCapacityMin(){return this._hdrCapacityMin}set hdrCapacityMin(e){this._hdrCapacityMin=e,this.calculateWeight()}get hdrCapacityMax(){return this._hdrCapacityMax}set hdrCapacityMax(e){this._hdrCapacityMax=e,this.calculateWeight()}get maxDisplayBoost(){return this._maxDisplayBoost}set maxDisplayBoost(e){this._maxDisplayBoost=Math.max(1,Math.min(65504,e)),this.calculateWeight()}calculateWeight(){const e=(Math.log2(this._maxDisplayBoost)-this._hdrCapacityMin)/(this._hdrCapacityMax-this._hdrCapacityMin);this.uniforms.weightFactor.value=Math.max(0,Math.min(1,e))}}class V extends Error{}class z extends Error{}const I=(h,e,t)=>{const a=new RegExp(`${e}="([^"]*)"`,"i").exec(h);if(a)return a[1];const i=new RegExp(`<${e}[^>]*>([\\s\\S]*?)</${e}>`,"i").exec(h);if(i){const r=i[1].match(/<rdf:li>([^<]*)<\/rdf:li>/g);return r&&r.length===3?r.map(o=>o.replace(/<\/?rdf:li>/g,"")):i[1].trim()}if(t!==void 0)return t;throw new Error(`Can't find ${e} in gainmap metadata`)},fe=h=>{let e;typeof TextDecoder<"u"?e=new TextDecoder().decode(h):e=h.toString();let t=e.indexOf("<x:xmpmeta");for(;t!==-1;){const a=e.indexOf("x:xmpmeta>",t),i=e.slice(t,a+10);try{const r=I(i,"hdrgm:GainMapMin","0"),o=I(i,"hdrgm:GainMapMax"),s=I(i,"hdrgm:Gamma","1"),l=I(i,"hdrgm:OffsetSDR","0.015625"),d=I(i,"hdrgm:OffsetHDR","0.015625"),c=/hdrgm:HDRCapacityMin="([^"]*)"/.exec(i),f=c?c[1]:"0",n=/hdrgm:HDRCapacityMax="([^"]*)"/.exec(i);if(!n)throw new Error("Incomplete gainmap metadata");const u=n[1];return{gainMapMin:Array.isArray(r)?r.map(g=>parseFloat(g)):[parseFloat(r),parseFloat(r),parseFloat(r)],gainMapMax:Array.isArray(o)?o.map(g=>parseFloat(g)):[parseFloat(o),parseFloat(o),parseFloat(o)],gamma:Array.isArray(s)?s.map(g=>parseFloat(g)):[parseFloat(s),parseFloat(s),parseFloat(s)],offsetSdr:Array.isArray(l)?l.map(g=>parseFloat(g)):[parseFloat(l),parseFloat(l),parseFloat(l)],offsetHdr:Array.isArray(d)?d.map(g=>parseFloat(g)):[parseFloat(d),parseFloat(d),parseFloat(d)],hdrCapacityMin:parseFloat(f),hdrCapacityMax:parseFloat(u)}}catch{}t=e.indexOf("<x:xmpmeta",a)}};class ce{constructor(e){this.options={debug:e&&e.debug!==void 0?e.debug:!1,extractFII:e&&e.extractFII!==void 0?e.extractFII:!0,extractNonFII:e&&e.extractNonFII!==void 0?e.extractNonFII:!0}}extract(e){return new Promise((t,a)=>{const i=this.options.debug,r=new DataView(e.buffer);if(r.getUint16(0)!==65496){a(new Error("Not a valid jpeg"));return}const o=r.byteLength;let s=2,l=0,d;for(;s<o;){if(++l>250){a(new Error(`Found no marker after ${l} loops 😵`));return}if(r.getUint8(s)!==255){a(new Error(`Not a valid marker at offset 0x${s.toString(16)}, found: 0x${r.getUint8(s).toString(16)}`));return}if(d=r.getUint8(s+1),i&&console.log(`Marker: ${d.toString(16)}`),d===226){i&&console.log("Found APP2 marker (0xffe2)");const c=s+4;if(r.getUint32(c)===1297106432){const f=c+4;let n;if(r.getUint16(f)===18761)n=!1;else if(r.getUint16(f)===19789)n=!0;else{a(new Error("No valid endianness marker found in TIFF header"));return}if(r.getUint16(f+2,!n)!==42){a(new Error("Not valid TIFF data! (no 0x002A marker)"));return}const u=r.getUint32(f+4,!n);if(u<8){a(new Error("Not valid TIFF data! (First offset less than 8)"));return}const g=f+u,x=r.getUint16(g,!n),w=g+2;let _=0;for(let p=w;p<w+12*x;p+=12)r.getUint16(p,!n)===45057&&(_=r.getUint32(p+8,!n));const M=g+2+x*12+4,C=[];for(let p=M;p<M+_*16;p+=16){const m={MPType:r.getUint32(p,!n),size:r.getUint32(p+4,!n),dataOffset:r.getUint32(p+8,!n),dependantImages:r.getUint32(p+12,!n),start:-1,end:-1,isFII:!1};m.dataOffset?(m.start=f+m.dataOffset,m.isFII=!1):(m.start=0,m.isFII=!0),m.end=m.start+m.size,C.push(m)}if(this.options.extractNonFII&&C.length){const p=new Blob([r]),m=[];for(const D of C){if(D.isFII&&!this.options.extractFII)continue;const X=p.slice(D.start,D.end+1,"image/jpeg");m.push(X)}t(m)}}}s+=2+r.getUint16(s+2)}})}}const ge=async h=>{const e=fe(h);if(!e)throw new z("Gain map XMP metadata not found");const a=await new ce({extractFII:!0,extractNonFII:!0}).extract(h);if(a.length!==2)throw new V("Gain map recovery image not found");return{sdr:new Uint8Array(await a[0].arrayBuffer()),gainMap:new Uint8Array(await a[1].arrayBuffer()),metadata:e}},E=h=>new Promise((e,t)=>{const a=document.createElement("img");a.onload=()=>{e(a)},a.onerror=i=>{t(i)},a.src=URL.createObjectURL(h)});class pe extends ae{constructor(e,t){super(t),e&&(this._renderer=e),this._internalLoadingManager=new ie}setRenderer(e){return this._renderer=e,this}setRenderTargetOptions(e){return this._renderTargetOptions=e,this}prepareQuadRenderer(){this._renderer||console.warn("WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.");const e=new he({gainMapMax:[1,1,1],gainMapMin:[0,0,0],gamma:[1,1,1],offsetHdr:[1,1,1],offsetSdr:[1,1,1],hdrCapacityMax:1,hdrCapacityMin:0,maxDisplayBoost:1,gainMap:new F,sdr:new F});return new P({width:16,height:16,type:L,colorSpace:U,material:e,renderer:this._renderer,renderTargetOptions:this._renderTargetOptions})}async render(e,t,a,i){const r=i?new Blob([i],{type:"image/jpeg"}):void 0,o=new Blob([a],{type:"image/jpeg"});let s,l,d=!1;if(typeof createImageBitmap>"u"){const n=await Promise.all([r?E(r):Promise.resolve(void 0),E(o)]);l=n[0],s=n[1],d=!0}else{const n=await Promise.all([r?createImageBitmap(r,{imageOrientation:"flipY"}):Promise.resolve(void 0),createImageBitmap(o,{imageOrientation:"flipY"})]);l=n[0],s=n[1]}const c=new F(l||new ImageData(2,2),O,y,y,v,H,A,B,1,U);c.flipY=d,c.needsUpdate=!0;const f=new F(s,O,y,y,v,H,A,B,1,ne);f.flipY=d,f.needsUpdate=!0,e.width=s.width,e.height=s.height,e.material.gainMap=c,e.material.sdr=f,e.material.gainMapMin=t.gainMapMin,e.material.gainMapMax=t.gainMapMax,e.material.offsetHdr=t.offsetHdr,e.material.offsetSdr=t.offsetSdr,e.material.gamma=t.gamma,e.material.hdrCapacityMin=t.hdrCapacityMin,e.material.hdrCapacityMax=t.hdrCapacityMax,e.material.maxDisplayBoost=Math.pow(2,t.hdrCapacityMax),e.material.needsUpdate=!0,e.render()}}class ue extends pe{load(e,t,a,i){const r=this.prepareQuadRenderer(),o=new re(this._internalLoadingManager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(this.withCredentials),this.manager.itemStart(e),o.load(e,async s=>{if(typeof s=="string")throw new Error("Invalid buffer, received [string], was expecting [ArrayBuffer]");const l=new Uint8Array(s);let d,c,f;try{const n=await ge(l);d=n.sdr,c=n.gainMap,f=n.metadata}catch(n){if(n instanceof z||n instanceof V)console.warn(`Failure to reconstruct an HDR image from ${e}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`),f={gainMapMin:[0,0,0],gainMapMax:[1,1,1],gamma:[1,1,1],hdrCapacityMin:0,hdrCapacityMax:1,offsetHdr:[0,0,0],offsetSdr:[0,0,0]},d=l;else throw n}try{await this.render(r,f,d,c)}catch(n){this.manager.itemError(e),typeof i=="function"&&i(n),r.disposeOnDemandRenderer();return}typeof t=="function"&&t(r),this.manager.itemEnd(e),r.disposeOnDemandRenderer()},a,s=>{this.manager.itemError(e),typeof i=="function"&&i(s)}),r}}export{ue as H};
